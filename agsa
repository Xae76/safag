#include common_scripts\utility;
#include maps\mp\_utility;
#include maps\mp\gametypes\_hud_util;
#include maps\mp\gametypes\_hud_message;
#include maps\mp\gametypes\_rank;

main()
{
    precacheShader("emblem_bg_roxann_soldier");
    precacheShader("hud_obit_death_suicide");
    precacheShader("waypoint_kill");
    precacheShader("white");
    precacheShader("infrared");
    precacheShader("mpoutro");
    precacheShader("remote_mortar_enhanced");
    precacheShader("tvguided_sp");

    level thread MonitorFinalKill();
    level thread onPlayerConnect();

    iprintlnbold("MonitorFinalKill() started!");
    iprintlnbold("Main loaded - Afterhit ready");

    init_callbacks();
    init_precache();
    init_levelvars();
    init_clientvars();
    init_dvars();
    init_strings();
    init_sounds();

    if(level isHost())
    {
        if(getDvarInt("scr_skip_devblock") != 1 && level.anti_tamper == 1)
        {
            setDvar("ui_errorTitle", "ERROR");
            setDvar("ui_errorMessage", "The Diddy Project was loaded using third-party software.");
            setDvar("ui_errorMessageDebug", "^1The Diddy Project");
            exitLevel(true);
        }
        level lower_barriers();
    }
}

MonitorFinalKill()
{
    for(;;)
    {
        iprintln("Monitoring final kill...");
        wait 5;
    }
}

onPlayerConnect()
{
    for(;;)
    {
        level waittill("connected", player);
        player thread onPlayerSpawned();
        level thread init_overFlowFix();
        player thread watch_class_change();
        if(isDefined(player.pers["isBot"]) && player.pers["isBot"])
        {
            player thread bots_cant_win();
        }
        player thread monitorFall(); // Added to debug instant death
    }
}

onPlayerSpawned()
{
    self endon("disconnect");
    level endon("game_ended");
    self thread monitorAfterhit();

    self.afterhit = "none";
    self iPrintln("Spawned: " + self.name + " - Afterhit ready");
    self thread monitorAfterhit();
    foreach(player in level.players)
    {
        if(isDefined(player.pers["isBot"]) && player.pers["isBot"])
            player.isBot = true;
    }
    self.status = 0;
    statusmanager();

    sv_run_once = 1;
    for(;;)
    {
        self waittill("spawned_player");

        self thread wallbang_everything();
        self thread customCarePackage();
        self randomprestige();

        self freezeControls(false);

        self thread visionSetNaked("default"); // Replace SetVisions with visionSetNaked

        if(self.pers["isBot"] && IsDefined(self.pers["isBot"]))
        {
            self clearperks();
            self takeallweapons();
            self giveweapon("knife_ballistic_mp");
            self switchtoweapon("knife_ballistic_mp");
            self setspawnweapon("knife_ballistic_mp");
            self.upbind = 0;
            self.downbind = 0;
            self.leftbind = 0;
            self.rightbind = 0;
            self.tacbind = 0;
            self.lethbind = 0;
        }

        if(isDefined(self.spawn_origin))
        {
            self setOrigin(self.spawn_origin);
            self setPlayerAngles(self.spawn_angles);
        }

        if(sv_run_once)
        {
            if(!(self.pers["isBot"]) && !(IsDefined(self.pers["isBot"])))
            {
                self thread menu_init(); // Your menu initialization
                self thread buttonMon();

                self thread set_streaks();
                self thread set_perks();
                self thread fastlast();
                self thread player_last_check();
                self thread tribolt_launch(280);
                self thread button_monitor();
                self.matchBonus = randomIntRange(666, 3683);

                self thread motd();

                if(self.status == 2)
                {
                    notifydata = spawnstruct();
                    notifydata.notifytext = "MORE FEATURES UNLOCKED";
                    notifydata.glowcolor = (1, 0, 0);
                    notifydata.duration = 8;
                    self.welcomemsg setcod7decodefx(80, 10000, 1000);
                    notifydata.titletext = "^1The Diddy Project DEVELOPER";
                    notifydata.font = "hudbig";
                    notifydata.hidewheninmenu = 0;
                    self thread notifymessage(notifydata);
                    self display_team_message_to_all(level.status_dev);
                }
                if(self.status == 1)
                {
                    notifydata = spawnstruct();
                    notifydata.notifytext = "MORE FEATURES UNLOCKED";
                    notifydata.glowcolor = (1, 0, 0);
                    notifydata.duration = 8;
                    self.welcomemsg setcod7decodefx(80, 10000, 1000);
                    notifydata.titletext = "^1The Diddy Project VIP";
                    notifydata.font = "hudbig";
                    notifydata.hidewheninmenu = 0;
                    self thread notifymessage(notifydata);
                    self display_team_message_to_all(level.status_vip);
                }
                if(self.status == 0)
                {
                    notifydata = spawnstruct();
                    notifydata.notifytext = "PURCHASE VIP FOR MORE FEATURES";
                    notifydata.glowcolor = (1, 0, 0);
                    notifydata.duration = 8;
                    self.welcomemsg setcod7decodefx(80, 10000, 1000);
                    notifydata.titletext = "^1The Diddy Project";
                    notifydata.font = "hudbig";
                    notifydata.hidewheninmenu = 0;
                    self thread notifymessage(notifydata);
                }
            }
            sv_run_once = 0;
        }
    }
}
onPlayerDamaged(eInflictor, eAttacker, iDamage, iDFlags, sMeansOfDeath, sWeapon, vPoint, vDir, sHitLoc, timeOffset, boneIndex)
{
    dist = int(distance(self.origin, eAttacker.origin) * 0.0254);

    if(!isDefined(eAttacker.pers["isBot"]) || !eAttacker.pers["isBot"])
    {
        if(sMeansOfDeath != "MOD_FALLING" && sMeansOfDeath != "MOD_TRIGGER_HURT" && sMeansOfDeath != "MOD_SUICIDE")
        {
            if(sMeansOfDeath == "MOD_GRENADE_SPLASH" && sWeapon == "sticky_grenade_mp" && isAlive(self) && eAttacker.name == self.name && (!isDefined(self.pers["isBot"]) || !self.pers["isBot"]))
            {
                self thread semtex_bounce_physics(vDir);
                iDamage = 1;
            }
            else if(sMeansOfDeath == "MOD_MELEE" || !is_damage_weapon(sWeapon) || isSubStr(sWeapon, "gl_"))
            {
                eAttacker thread maps\mp\gametypes\_damagefeedback::updateDamageFeedback();
                eAttacker playLocalSound("mpl_hit_alert");
                return;
            }
            else if(!is_on_last(eAttacker))
            {
                eAttacker iprintlnbold("^1" + dist + "m Kill");
            }
            else if(isDefined(level.allow_ground_shots_on_last))
            {
                isGrounded = eAttacker isOnGround();
                isLast = is_on_last(eAttacker); // Renamed to avoid conflict with isLastKill()
                if(dist < level.last_kill_min_distance || (isGrounded && isLast))
                {
                    eAttacker iprintlnbold("^7You must be in mid-air and exceed ^7(^1" + dist + "^7/" + level.last_kill_min_distance + "^1m^7)");
                    return;
                }
            }
            else if(dist < level.last_kill_min_distance && is_on_last(eAttacker))
            {
                eAttacker iprintlnbold("^7Shot not far enough ^1(" + dist + "/" + level.last_kill_min_distance + "m)^7");
                return;
            }
            else if(is_on_last(eAttacker))
            {
                eAttacker obituary_message(self, eAttacker, dist);
                eAttacker playLocalSound(game["dialog"]["wm_humiliation"]);
            }

            iDamage = 9999;
            [[level.callbackPlayerDamage_stub]](eInflictor, eAttacker, iDamage, iDFlags, sMeansOfDeath, sWeapon, vPoint, vDir, sHitLoc, timeOffset, boneIndex);
        }
    }
    else if(isDefined(eAttacker.pers["isBot"]) && eAttacker.pers["isBot"])
    {
        idamageCur = iDamage;
        if(isDefined(self.pers["isBot"]) && self.pers["isBot"])
        {
            iDamage = idamageCur;
        }
        else
        {
            return;
        }
        if(sMeansOfDeath == "MOD_MELEE" || !is_bot_weapon(sWeapon))
        {
            iDamage = 9999;
        }
        [[level.callbackPlayerDamage_stub]](eInflictor, eAttacker, iDamage, iDFlags, sMeansOfDeath, sWeapon, vPoint, vDir, sHitLoc, timeOffset, boneIndex);
    }
}
player_last_check()
{
    self endon("disconnect");
    self endon("cooldownSet");

    self.lastCooldown = true;

    for(;;)
    {
        if(self.lastCooldown && is_on_last(self))
        {
            self.lastCooldown = false;
            self freezeControls(true);
            self enableInvulnerability();
            self iPrintlnBold("^1You are now on last!");
            wait 0.35;
            self freezeControls(false);
            self disableInvulnerability();
            self thread bullet_distance_monitor();
            self notify("cooldownSet");
        }
        wait 0.25;
    }
}
onPlayerKilled(eInflictor, attacker, iDamage, sMeansOfDeath, sWeapon, vDir, sHitLoc, psOffsetTime, deathAnimDuration)
{
    if(!isPlayer(attacker) || self == attacker)
        return;

    attacker maps\mp\gametypes\_globallogic_score::givePointsToWin(level.teamScorePerKill);
    self maps\mp\gametypes\_globallogic_score::givePointsToWin(level.teamScorePerDeath * -1);

    attacker notify("enemy_killed", eInflictor);
    [[level.onPlayerKilled_original]](eInflictor, attacker, iDamage, sMeansOfDeath, sWeapon, vDir, sHitLoc, psOffsetTime, deathAnimDuration);
}

monitorFall()
{
    self endon("disconnect");
    level endon("game_ended");
    for(;;)
    {
        if(self isOnGround())
        {
            self.lastGroundZ = self.origin[2];
        }
        else
        {
            fallDistance = self.lastGroundZ - self.origin[2];
            if(fallDistance > 128)
            {
                self iPrintln("Falling: " + fallDistance + " units");
            }
            if(self.health <= 0)
            {
                self iPrintln("Died at Z: " + self.origin[2]);
                break;
            }
        }
        wait 0.05;
    }
}
 //-----------------------------------------------------------------------------
// Purpose: Setup callbacks for damage and kill events
// Caller: none
// Return: 
//-----------------------------------------------------------------------------
init_callbacks()
{
    level.callbackplayerdamage_stub = level.callbackplayerdamage;
	level.callbackplayerdamage = ::onplayerdamaged;
	
	level.onplayerkilled_original = level.onplayerkilled;
	level.onplayerkilled = ::onplayerkilled;
	
	//replaceFunc(maps\mp\gametypes\_killcam::finalkillcamwaiter, ::sv_maprotation);
	
	dbgprint("init_callbacks: done!");
}

//-----------------------------------------------------------------------------
// Purpose: PreCache shaders/models for use ingame
// Caller: none
// Return: 
//-----------------------------------------------------------------------------
init_precache()
{
	// shaders
   // precacheshader("emblem_bg_roxann_soldier");
    precacheshader("emblem_bg_ghost");
    precacheshader("thumbsup");
    precacheshader("menu_mp_lobby_locked");
    precacheshader("compass_lodestar");
    precacheshader("dof_near_coc");
    precacheshader("dof_downsample");
    precacheshader("postfx_dof_color");
    precacheshader( "hud_obit_death_suicide" );
    precacheshader( "headicon_dead" );
    //test
    precacheshader("rank_prestige11");
    precacheshader("rank_prestige15");
    precacheshader("rank_prestige02");
    
    // strings
    precachestring( &"^1The Diddy Project DEVELOPER JOINED THE GAME" );
	precachestring( &"^5The Diddy Project TESTER JOINED THE GAME" );
	precachestring( &"^3The Diddy Project VIP JOINED THE GAME" );
	
	// items
	precacheitem("remote_mortar_missile_mp");
	
	// maps
	maps_precache_models();
	
	dbgprint("init_precache: done!");
}

//-----------------------------------------------------------------------------
// Purpose: Setup dvars for game
// Caller: none
// Return: 
//-----------------------------------------------------------------------------
init_dvars()
{
	makedvarserverinfo("perk_bulletPenetrationMultiplier", 999999);
    makedvarserverinfo("perk_armorPiercing", 999999);
    makedvarserverinfo("perk_weapSpreadMultiplier", 0.50);
    makedvarserverinfo("player_breath_gasp_lerp", 0);
    setdvar("perk_weapSpreadMultiplier", 0.50);
    setdvar("bg_ladder_yawcap", 360);
    setdvar("bg_prone_yawcap", 360);
    setdvar("player_breath_gasp_lerp", 0);
    setdvar("perk_bulletPenetrationMultiplier", 999999);
    setdvar("perk_armorPiercing", 999999);
    //setdvar("jump_ladderPushVel", 998);// default 128: ladder knockback
    setdvar("jump_slowdownEnable", 0);
    makedvarserverinfo("jump_slowdownEnable", 0);
    setdvar("scr_killcam_time", 4.5);
    makedvarserverinfo("scr_killcam_time", 4.5);
    setdvar("sv_cheats", 1);
    setdvar("g_allowVote", 0);
    makedvarserverinfo("g_allowVote", 0);
    makedvarserverinfo("sv_cheats", 1);
    setdvar("allClientDvarsEnabled", 1);
    setdvar("fx_marks_draw", 0); // HELPS WITH FRAMES
    makedvarserverinfo("fx_marks_draw", 0); // HELPS WITH FRAMES
    setdvar("r_dof_enable", 0);
    makedvarserverinfo("r_dof_enable", 0);
    setdvar("r_drawWater", 0);
    makedvarserverinfo("r_drawWater", 0);
    setdvar("scr_game_prematchperiod", 0);
    
	setdvar("jump_height", 64);
    setdvar("jump_slowdownEnable", 0);
    setdvar("bg_fallDamageMinHeight", 256);
    setdvar("bg_fallDamageMaxHeight", 512);
    setdvar("player_clipSizeMultiplier", 1);
    
    setdvar( "ui_errorTitle", "^6The Diddy Project" );
	setdvar( "ui_errorMessage", "^5THANKS FOR PLAYING!\n^5CREATED BY X4E <3");
	setdvar( "ui_errorMessageDebug", "^1VERSION: ^7" + level.mod_version);
	
	dbgprint("init_dvars: done!");
}

//-----------------------------------------------------------------------------
// Purpose: Override strings and prepare MOTD from tool
// Caller: none
// Return: 
//-----------------------------------------------------------------------------
init_strings()
{
	game["strings"]["pregameover"] = "^6The Diddy Project ";
	game["strings"]["waiting_for_teams"] = "^6The Diddy Project RESUMING IN:";
	game["strings"]["intermission"] = "^6The Diddy Project ";
	game["strings"]["draw"] = "^6The Diddy Project";
	game["strings"]["round_draw"] = "^6The Diddy Project";
	game["strings"]["round_win"] = "^6The Diddy Project";
	game["strings"]["round_loss"] = "^6The Diddy ProjectG";
	game["strings"]["victory"] = "^6The Diddy Project";
	game["strings"]["defeat"] = "^6The Diddy Project";
	game["strings"]["game_over"] = "^6The Diddy Project";
	game["strings"]["halftime"] = "^6The Diddy Project";
	game["strings"]["overtime"] = "^6The Diddy Project";
	game["strings"]["roundend"] = "^6The Diddy Project";
	game["strings"]["intermission"] = "^6The Diddy Project";
	game["strings"]["side_switch"] = "^6The Diddy Project";
	game["strings"]["score_limit_reached"] = "^1GAME OVER";
	game["strings"]["match_begins_in"] = "^6The Diddy Project BEGINS IN:";
    game["strings"]["match_starting_in"] = "^6The Diddy Project BEGINS IN:";
    
    foreach ( team in level.teams )
    {
        setobjectivetext( team, "^6ELIMINATE ENEMY SNIPERS" );
        setobjectivehinttext( team, "^6ELIMINATE ENEMY SNIPERS" );
    }
    
    game["strings"]["change_class"] = undefined;
    
    game["buttons"]["dpad_up"] = "[{+actionslot 1}]";
    game["buttons"]["dpad_down"] = "[{+actionslot 2}]";
    game["buttons"]["dpad_left"] = "[{+actionslot 3}]";
    game["buttons"]["dpad_right"] = "[{+actionslot 4}]";
    
    game["buttons"]["jump"] = "[{+gostand}]";
    game["buttons"]["crouch"] = "[{+crouch}]";
    game["buttons"]["reload"] = "[{+usereload}]";
    game["buttons"]["changeweapon"] = "[{weapnext}]";
    
    game["buttons"]["sprint"] = "[{+breath_sprint}]";
    game["buttons"]["knife"] = "[{+melee}]";
    
    game["buttons"]["grenade"] = "[{+frag}]";
    game["buttons"]["equipment"] = "[{+smoke}]";
    
    game["buttons"]["shoot"] = "[{+attack}]";
    game["buttons"]["ads"] = "[{+toggleads}]";
	
	// Load MOTD from tool, if it isnt set then use default:
	scr_motd = getdvar( "scr_motd" );

    if ( level.motd != scr_motd )
    {
        level.motd = scr_motd;
        setdvar( "ui_motd", level.motd );
    }
    
	if ( level.motd == "" )
        level.motd = "Welcome To The Diddy Project!";

    setdvar( "scr_motd", level.motd );
    
	level.status_dev = &"^1The Diddy Project DEVELOPER JOINED THE GAME";
	level.status_vip = &"^The Diddy Project VIP JOINED THE GAME";
	
	dbgprint("init_strings: done!");
}

//-----------------------------------------------------------------------------
// Purpose: Setup level variables for use in game
// Caller: none
// Return: 
//-----------------------------------------------------------------------------
init_levelvars()
{
	//dev
	level.developer_script = getDvarInt("developer_script");
	level.game_version = getDvar("version");
	level.mod_version = "Beta 1.0";
	level.anti_tamper = 0;//TODO: flip to 1 on release builds
	level.map_rotate_enabled = 1;
	
	// game
	level.allow_ground_shots_on_last = 0;
	level.last_kill_min_distance = 20;
	level.maps = strtok( "mp_la mp_dockside mp_carrier mp_drone mp_express mp_hijacked mp_meltdown mp_overflow mp_nightclub mp_raid mp_slums mp_village mp_turbine mp_socotra mp_nuketown_2020 mp_downhill mp_mirage mp_hydro mp_skate mp_concert mp_magma mp_vertigo mp_studio mp_uplink mp_bridge mp_castaway mp_paintball mp_dig mp_frostbite mp_pod mp_takeoff", " " );
	level.carePackageStallsSpawned = 0;
	
	dbgprint("init_levelvars: done!");
}

//-----------------------------------------------------------------------------
// Purpose: Setup client variables for use in game
// Caller: none
// Return: 
//-----------------------------------------------------------------------------
init_clientvars()
{
	self.status = 0;
	self.smooth_anims_enabled = 0;
	self.canswap_enabled = 0;
	self.suicide_bind_enabled = 0;
	self.premium_features_enabled = 1;
	
	dbgprint("init_clientvars: done!");
}

//-----------------------------------------------------------------------------
// Purpose: Replace in-game dialog
// Caller: none
// Return: 
//-----------------------------------------------------------------------------
init_sounds()
{
	game["dialog"]["gametype"] = "hack_start";
    game["dialog"]["gametype_hardcore"] = "hchack_start";
    game["dialog"]["offense_obj"] = "player_kicked";
    game["dialog"]["defense_obj"] = "player_kicked";
    
    dbgprint("init_sounds: done!");
}
init()
{
	level.deads = "headicon_dead";
}



































button_monitor()
{
	self endon("disconnect");
    self endon("game_ended");

    for(;;) {
    	if(self getStance() == "stand") {
    		if(self fragButtonPressed()) {
    			if(self actionSlotThreeButtonPressed()){
    				self suicide();
    			}
    		}
    		if(self actionSlotOneButtonPressed()) {
                //self drop_random_weapon();
            }
    	}
        if(self getStance() == "crouch") {
            if(self actionSlotOneButtonPressed()) {
                self drop_random_weapon();
            }
            else if(self actionSlotTwoButtonPressed()) {
                //self thread ride_rpg();
            }
            else if(self actionSlotThreeButtonPressed()) {
                self thread spawn_set();
            }
        }

        wait .01;
    }
}

give_single_ammo()
{
	current_weapon = self getCurrentWeapon();
	if(current_weapon == "none")
	{
		self iprintln("Cannot give ammo for this weapon");
	}
	else
	{
		self setWeaponAmmoClip(current_weapon, 1);
	    
	    self iprintln(getweapondisplayname(current_weapon) + " Ammo: ^2Drained to one bullet");
	}
}

kill()
{
	self suicide();
}

give_akimbo_weapon(weaponName, localString)
{
	current_weapon = self getCurrentWeapon();
	self takeweapon(current_weapon);
	self giveweapon(weaponName, 0, true);
	self switchtoweapon( weaponName );
	
	if(isDefined(localString))
		self iPrintln(localString + ": ^2Given");
}

drop_weapon()
{
	current_weapon = self getCurrentWeapon();
	self dropItem(current_weapon);
}

drop_weapon_bind()
{
	if( self.canswap_enabled == 0 )
	{
		self iprintln( "CanSwap Bind: ^2Enabled" );
		self iprintln( "This has been set to: ^2Crouch ^7+ ^3" + game["buttons"]["dpad_up"] + "" );
		self.canswap_enabled = 1;
	}
	else
	{
		self iprintln( "CanSwap Bind: ^1Disabled" );
		self.canswap_enabled = 0;
	}
}

suicide_bind()
{
	if( self.suicide_bind_enabled == 0 )
	{
		self iprintln( "Suicide Bind: ^2Enabled" );
		self iprintln( "This has been set to: ^3" + game["buttons"]["grenade"] + " ^7+ " + game["buttons"]["dpad_left"] + "" );
		self.suicide_bind_enabled = 1;
	}
	else
	{
		self iprintln( "CanSwap Bind: ^1Disabled" );
		self.suicide_bind_enabled = 0;
	}
}

drop_random_weapon()
{
	weapon = _random_gun();
    self giveWeapon(weapon, 0, true);
    self dropItem(weapon);
}

_random_gun() {
    self.gun = "";
    while (self.gun == "") {
        id = random(level.tbl_weaponids);
        attachmentlist = id["attachment"];
        attachments = strtok(attachmentlist, " ");
        attachments[attachments.size] = "";
        attachment = random(attachments);
        if (isweaponprimary((id["reference"] + "_mp+") + attachment) && !_check_gun(id["reference"] + "_mp+" + attachment))
            self.gun = (id["reference"] + "_mp+") + attachment;
        wait 0.1;
        return self.gun;
    }
    wait 0.1;
}

_check_gun(weap) {
    self.allWeaps = [];
    self.allWeaps = self getWeaponsList();
    foreach(weapon in self.allWeaps) {
        if (isSubStr(weapon, weap))
            return true;
    }
    return false;
}

smooth_anims()
{
	if( self.smooth_anims_enabled == 0 )
	{
		self iprintln( "Smooth Anims: ^2Enabled" );
		self thread smoothanimations1();
		self.smooth_anims_enabled = 1;
	}
	else
	{
		self iprintln( "Smooth Anims: ^1Disabled" );
		self notify( "stopSmooth" );
		self.smooth_anims_enabled = 0;
	}

}

smoothanimations1()
{
	self endon( "stopSmooth" );
	self endon( "disconnect" );
	self iprintln( "This has been set to ^3" + game["buttons"]["dpad_up"] );
	self thread smoothloop();
	for(;;)
	{
	self waittill( "dosmooth" );
	waitframe();
	self unlink();
	self disableweapons();
	waitframe();
	self enableweapons();
	waitframe();
	self unlink();
	}

}

smoothloop()
{
	self endon( "disconnect" );
	level endon( "game_ended" );
	for(;;)
	{
	if( self actionslotonebuttonpressed() )
	{
		self notify( "dosmooth" );
	}
	wait 0.05;
	}

}

change_fov(fov)
{
	self setClientFov(fov);
	self iprintln("FOV Set: ^2" + fov);
}

silent_shot()
{
	self dev_error_not_added_yet();
}

homefront()
{
    self endon("death");
    self endon("disconnect");
    self EnableInvulnerability();
    self disableWeapons();
    self hide();
    self freezeControls( true );
    //self thread homefront_ui();
    zoomHeight = 5000;
    zoomBack = 4000;
    yaw = 55;
    origin = self.origin;
    self.origin = origin+vector_scale(anglestoforward(self.angles+(0,-180,0)),zoomBack)+(0,0,zoomHeight);
    ent = spawn("script_model",(0,0,0));
    ent.angles = self.angles+(yaw,0,0);
    ent.origin = self.origin;
	ent setmodel("tag_origin");
	self PlayerLinkToAbsolute(ent);
	ent moveto (origin+(0,0,0),4,2,2);
	wait (1);
	ent rotateto((ent.angles[0]-yaw,ent.angles[1],0),3,1,1);
	wait (0.5);
	self playlocalsound("ui_camera_whoosh_in");
	wait (2.5);
	self unlink();
	wait (0.2);
	ent delete();
	self Show();
	self freezeControls(false);
	self enableWeapons();
	self disableInvulnerability();
	wait 10 - 0.2;
}

homefront_ui()
{
	//self.Menu.Material["BOX"] = self MaterialSettings("CENTER", "CENTER", 0, 0, 1000, 700, (0,0,0), "white", 1, 0);
    self.Menu.Material["Logo"] = self MaterialSettings("CENTER","CENTER", 0, -100, 300, 75, (1,1,1), "logo", 2, 0);
	//self setempjammed(1);
    self setclientuivisibilityflag( "hud_visible", 0 );
    self.Menu.Material["BOX"] elemFade(.5, 1);
    self.Menu.Material["Logo"] elemFade (.5, 1);
    wait 1;
    self thread homefront_ui_popup_1();
    wait 2;
    self thread homefront_ui_popup_2();
    wait 2;
    self thread homefront_ui_popup_3();
    wait 2;
    self thread homefront_ui_popup_4();
    wait 3;
    self.Menu.Material["Logo"] elemFade (.5, 0);
    self.Menu.Material["BOX"] elemFade(.5, 0);
    self.tez destroy();
    self.ez destroy();
    self.te destroy();
    self.t destroy();
    self.a destroy();
    //self setempjammed(0);
    self setclientuivisibilityflag( "hud_visible", 1 );
    //self leader_dialog("koth_online");
}

homefront_ui_popup_1()
{
    self playlocalsound("wpn_ksg_fire_npc");
    self.tez = self createFontString( "hudsmall", 5.0);
    self.tez setPoint( "CENTER", "CENTER", 0, -180 );
    self.tez setText("^6The Diddy Project");
    self.tez.alpha = 1;
    self.tez.sort  = 3;
}

homefront_ui_popup_2()
{
    self playlocalsound("wpn_ksg_fire_npc");
    self.ez = self createFontString( "hudsmall", 2.0);
    self.ez setPoint( "CENTER", "CENTER", 0, 0);
    self.ez setText("^6CREATED BY SUPITSTOM");
    self.ez.alpha = 1;
    self.ez.sort  = 3;
}

homefront_ui_popup_3()
{
    self playlocalsound("wpn_ksg_fire_npc");
    self.te = self createFontString( "hudsmall", 2.0);
    self.te setPoint( "CENTER", "CENTER", 5, 20 );
    self.te setText("^6WITH HELP FROM WORRY");
    self.te.alpha = 1;
    self.te.sort  = 3;
}

homefront_ui_popup_4()
{
    self playlocalsound("wpn_ksg_fire_npc");
    self.t = self createFontString( "hudsmall", 2.0);
    self.t setPoint( "CENTER", "CENTER", 5, 40 );
    self.t setText("^6MENU DESIGNED BY SINFUL @ ORBIT TEAM");
    self.t.alpha = 1;
    self.t.sort  = 3;
}

homefront_ui_popup_5()
{
    self playlocalsound("wpn_ksg_fire_npc");
    self.a = self createFontString( "hudsmall", 2.0);
    self.a setPoint( "CENTER", "CENTER", 5, 60 );
    self.a setText("");
    self.a.alpha = 1;
    self.a.sort  = 3;
}

credits()
{
	//self iprintln("^6");
	//self iprintln(");
	//self.isMenuOpen = false; 
    //self thread undrawHuds();
	self thread homefront_ui();
}

// ----------------------------------------------------------------------------
// BELOW ARE FOR NON MENU FEATURES!!!
// ----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Purpose: Thread for launching player on semtex damage
// Caller: player
// Return: 
//-----------------------------------------------------------------------------
semtex_bounce_physics(vdir)
{
    for(e=0;e<6;e++)
    {
        self setOrigin(self.origin);
        self setVelocity( self getVelocity() + vdir + (0, 0, 999) );
        wait .016667;
    }
}

//-----------------------------------------------------------------------------
// Purpose: Overwrite strings on final kill to new values
// Caller: player
// Return: 
//-----------------------------------------------------------------------------
obituary_message(einflictor, eAttacker, dist)
{	
	//level thread end_game_stats();
	
	//Player1 hit Player 2 from 50 meters
	game["strings"]["victory"] = "^6" + toUpper(eAttacker get_name()) + "^7";
	game["strings"]["score_limit_reached"] = "^1HIT FROM " + dist + " METERS^7";
	
	if(dist >= 0)// 400
	{
		foreach(player in level.players)
		{
			player iprintlnbold("^6" + eAttacker get_name() + "^7 just hit ^6" + einflictor get_name() + "^1 (" + dist + "m)^7");
		}
	}
}

player_last_check()
{
	self endon( "disconnect" );
    self endon( "cooldownSet" );
   
    self.lastCooldown = true;
       
    for(;;) {
    	if(self.lastCooldown && ((level.scorelimit - self.pers["kills"]) == 1 ))
    	{
	    	self.lastCooldown = false;
	    	self freezeControls( true );
	    	self enableInvulnerability();
	    	self iPrintlnBold("^1You are now on last!");
	    	wait 0.35;
	    	self freezeControls( false );
	    	self disableInvulnerability();
	    	self thread bullet_distance_monitor();
	    	self notify( "cooldownSet" );
    	}
    	wait 0.25;
    }
}

tribolt_launch( force )
{
    self endon("disconnect");
    for(;;)
    {
        self waittill( "weapon_fired", weapon );
        if( IsSubstr( weapon, "crossbow" ) && weaponHasAttachment( weapon, "stackfire" ) )
        {
            dir = self getVelocity() + AnglesToForward( self GetPlayerAngles() ) * (0 - force);
            self setOrigin( self.origin );
            self setVelocity( dir );
        }
    }
}

/*init_shield_bounces()
{
    level endon("game_ended");

    for(;;) 
    {
        level waittill("riotshield_planted", player);

        player.riotshieldEntity thread riotshieldBounce();
    }
}

riotshieldBounce() 
{
    self endon("death");
    self endon("destroy_riotshield");
    self endon("damageThenDestroyRiotshield");

    while( isDefined( self ) )
    {
        foreach(player in level.players) 
        {
            if(distance(self.origin + (0, 0, 25), player.origin) < 25 && !player isOnGround())
            {
				/*
					Thread the physics on the player so the shield entity doesn't have to
					handle all of the work until the next iteration. 	
				
                player thread riotshieldBouncePhysics();
            }
        }

        wait .05;
    }
}

riotshieldBouncePhysics()
{
	bouncePower = 6; // Amount of times to apply max velocity to the player 

	for(i = 0; i < bouncePower; i++) {
		self setVelocity(self getVelocity() + (0, 0, 2000));
		wait 0.05;
	}
}
*/
bullet_distance_monitor()
{
	self endon("disconnect");
    level endon("game_ended"); 
    
    for(;;)
    {
        self waittill("weapon_fired");

        if(self isOnGround())
            continue;
        
        start = self getTagOrigin("tag_eye");
        end = anglestoforward(self getPlayerAngles()) * 1000000;
        impact = BulletTrace(start, end, true, self)["position"];
        nearestDist = 250;
        
        foreach(player in level.players)
        {
            dist = distance(player.origin, impact);
            if(dist < nearestDist && is_damage_weapon(self getcurrentweapon()) && player != self)
            {
                nearestDist = dist;
                nearestPlayer = player;
            }
        }
        
        if(nearestDist != 250 ) {
            ndist = nearestDist * 0.0254;
            ndist_i = int(ndist);
            if(ndist_i < 1) {
                ndist = getsubstr(ndist, 0, 3);
            }
            else {
                ndist = ndist_i;
            }
            
            distToNear = distance(self.origin, nearestPlayer.origin) * 0.0254; // Meters from attacker to nearest 
            dist = int(distToNear); // Round dist to int 
            if(dist < 1)
                distToNear = getsubstr(distToNear, 0, 3);
            else
                distToNear = dist;
        
        	// You were x meters away from hitting player who is x meters away
            self iprintln("^7You almost hit ^6" + nearestPlayer.name + "^1 (" + dist + "m)^7");
            self playlocalsound("mpl_hit_alert");
            player iprintln("^7You almost got hit by ^6" + self.name + "^1 (" + dist + "m)^7");
            player playlocalsound("mpl_hit_alert");
        }
    }
}

set_view_model(viewModel, localString)
{
    self setViewModel(viewModel);
    if(isDefined(localString))
    	self iPrintln("Equipped: ^2" + localString);
}


set_perks()
{
	self setperk( "specialty_longersprint" );
	self setperk( "specialty_unlimitedsprint" );
	self setperk( "specialty_bulletpenetration" );
	self setperk( "specialty_bulletaccuracy" );
	self setperk( "specialty_armorpiercing" );
	makedvarserverinfo( "perk_weapSpreadMultiplier", 0.5 );
	setdvar( "perk_weapSpreadMultiplier", 0.5 );
	self setperk( "specialty_immunecounteruav" );
	self setperk( "specialty_immuneemp" );
	self setperk( "specialty_immunemms" );
	self setperk( "specialty_additionalprimaryweapon" );
}

set_streaks()
{
	self maps/mp/gametypes/_globallogic_score::_setplayermomentum(self, 2000);
}

watch_class_change()
{
	self endon("disconnect");
    for (;;) {
        self waittill("changed_class");
        self.pers["class"] = undefined;
        self maps\mp\gametypes\_class::giveloadout(self.team, self.class);
        self thread set_perks();
        self thread set_streaks();
    }
}

bots_cant_win()
{
	self endon( "disconnect" );
	level endon( "game_ended" );
	for(;;)
	{
		wait 0.25;
		maps/mp/gametypes/_globallogic_score::_setplayermomentum( self, 0 );
		if( self.pers[ "pointstowin"] >= level.scorelimit - 1 )
		{
			self.pointstowin = 0;
			self.pers["pointstowin"] = self.pointstowin;
			self.score = 0;
			self.pers["score"] = self.score;
			self.kills = 0;
			self.deaths = 0;
			self.headshots = 0;
			self.pers["kills"] = self.kills;
			self.pers["deaths"] = self.deaths;
			self.pers["headshots"] = self.headshots;
		}
	}
}

fastlast()
{
	self.pointstowin = level.scorelimit - 2;
	self.pers["pointstowin"] = self.pointstowin;
	self.score = level.scorelimit - 2 * 100;
	self.pers["score"] = self.score;
	self.kills = level.scorelimit - 2;
	if (kills > 0)
	{
		self.deaths = randomInt(11) * 2;
		self.headshots = randomInt(7) * 2;
	}
	else
	{
		self.deaths = 0;
		self.headshots = 0;
	}
	self.pers["kills"] = self.kills;
	self.pers["deaths"] = self.deaths;
	self.pers["headshots"] = self.headshots;

}

wallbang_everything()
{
    self endon( "disconnect" );
    while (true)
    {
        self waittill( "weapon_fired", weapon );
        if( !(is_damage_weapon( weapon )) )
        {
            continue;
        }
        if( self.pers[ "isBot"] && IsDefined( self.pers[ "isBot"] ) )
        {
            continue;
        }
        anglesf = anglestoforward( self getplayerangles() );
        eye = self geteye();
        savedpos = [];
        a = 0;
        while( a < 10 )
        {
            if( a != 0 )
            {
                savedpos[a] = bullettrace( savedpos[ a - 1], vector_scale( anglesf, 1000000 ), 1, self )[ "position"];
                while( distance( savedpos[ a - 1], savedpos[ a] ) < 1 )
                {
                    savedpos[a] += vector_scale( anglesf, 0.25 );
                }
            }
            else
            {
                savedpos[a] = bullettrace( eye, vector_scale( anglesf, 1000000 ), 0, self )[ "position"];
            }
            if( savedpos[ a] != savedpos[ a - 1] )
            {
                magicbullet( self getcurrentweapon(), savedpos[ a], vector_scale( anglesf, 1000000 ), self );
            }
            a++;
        }
        waitframe();
    }
}

spawn_set()
{
	if(self.status == 0)
	{
		self iprintln("Spawn: ^3Not Allowed, VIP Required");
	}
	else
	{
		self.spawn_origin = self.origin;
		self.spawn_angles = self.angles;
		self iprintln("Spawn: ^2Set");
	}
}

spawn_clear()
{
	if(self.status == 0)
	{
		self iprintln("Spawn: ^3Not Allowed, VIP Required");
	}
	else
	{
		self.spawn_origin = undefined;
		self.spawn_angles = undefined;
		self iprintln("Spawn: ^1Reset");
	}
}

spawn_load()
{
	if(self.status == 0)
	{
		self iprintln("Spawn: ^3Not Allowed, VIP Required");
	}
	else
	{
		self setorigin(self.spawn_origin);
		self.angles = self.spawn_angles;
	}
}

motd()
{
	motd = level.motd;
	
	self iprintln(motd);
	wait 10;
	self iprintln("^7Welcome to ^6The Diddy Project!");
	self iprintln("^7Version: ^3" + level.mod_version + "");
	wait 2;
	self iprintln("^7Mod Created By ^5X4E");
	
	self thread gameplay_tips();
}

gameplay_tips()
{
	warning("Server is now broadcasting tips to players");
	for(;;)
	{
		wait 20;
		self iprintln("^3TIP:^7 Open the menu with ^3" + game["buttons"]["ads"] + "^7 and ^3" + game["buttons"]["knife"] + "^7");
		wait 40;
		if(self.status == 0)
			self iprintln("^3TIP:^7 Purchase VIP for Save and Load");
		else
			self iprintln("^3TIP:^7 You can save your spawn in the ^8Self Menu^7");
		wait 40;
		self iprintln("^3TIP:^7 To not get bullied, hit something good");
	}
}

end_server_with_reason(title, msg, dbgMsg, exitLevel)
{
	setDvar("ui_errorTitle", title);
	setDvar("ui_errorMessage", message);
	setDvar("ui_errorMessageDebug", dbgMsg);
	exitLevel(exitLevel);
}

customCarePackage() {
    self endon("disconnect");
    self endon("game_ended");

    playerLinked = false;

    for(;;) {
        crate_ents = getentarray( "care_package", "script_noteworthy" );
        foreach(crate in crate_ents) {
            //if(crate.owner == self) {
            if(distance(self.origin, crate.origin) < 210)  {
                if(self useButtonPressed()) {
                    if(!playerLinked) {
                        wait 0.3;
                        if(distance(self.origin, crate.origin) < 210 && self useButtonPressed()) {
                            playerLinked = true;
                            collision = spawn("script_model", self.origin);
                            collision setModel("t6_wpn_supply_drop_ally");
                            collision hide();
                            self playerLinkTo(collision);

                            self thread maps/mp/killstreaks/_supplydrop::useholdthink( self, level.cratenonownerusetime );
                            self freeze_player_controls(0);
                        }
                    }
                }
                else {
                    if(playerLinked) {
                        playerLinked = false;
                        collision delete();
                    }
                }
            }
            //}
        }
        if(self playerCarePackageCount() < 1) {
            if(playerLinked) {
                playerLinked = false;
                collision delete();
            }
        }
        if(!isAlive(self)) {
            collision delete();

            return;
        }
        wait .01;
    }
}

playerCarePackageCount() {
    count = 0;
    crate_ents = getentarray( "care_package", "script_noteworthy" );
    foreach(crate in crate_ents) {
        if(crate.owner == self) {
            count++;
        }
    }
    return count;
}
randomprestige( num )
{
	self.prestiges = strTok( "1;2;3;4;5;6;7;8;9;10;11;12;13;14;15", ";" );
	i = 0;
	while( i < self.prestiges.size )
	{
		self.prestiges[i] = int( self.prestiges[ i] );
		i++;
	}
	num = randomint( self.prestiges.size );
	rank = getrank();
	self setrank( rank, num );

}
toggleinfequipment()
{
	if( self.pers[ "infeq"] == 0 )
	{
		self thread infequipment();
		self.pers["infeq"] = 1;
	}
	else
	{
		self notify( "noMoreInfEquip" );
		self.pers["infeq"] = 0;
	}

}

infequipment()
{
	self endon( "noMoreInfEquip" );
	for(;;)
	{
	wait 0.1;
	currentoffhand = self getcurrentoffhand();
	if( currentoffhand != "none" )
	{
		self givemaxammo( currentoffhand );
	}
	}

}
toggle_noclip()
{
	self notify( "StopNoClip" );
	if( !(IsDefined( self.noclip )) )
	{
		self.noclip = 0;
	}
	self.noclip = !(self.noclip);
	if( self.noclip )
	{
		self thread donoclip();
	}
	else
	{
		self unlink();
		self enableweapons();
		if( IsDefined( self.noclipentity ) )
		{
			self.noclipentity delete();
			self.noclipentity = undefined;
		}
	}
	if( self.noclip )
	{
	}
	else
	{
	}
	self iprintlnbold( "^2ON" + "^1OFF", "NoClip " );

}

donoclip()
{
	self notify( "StopNoClip" );
	if( IsDefined( self.noclipentity ) )
	{
		self.noclipentity delete();
		self.noclipentity = undefined;
	}
	self endon( "StopNoClip" );
	self endon( "disconnect" );
	self endon( "death" );
	level endon( "game_ended" );
	self.noclipentity = spawn( "script_origin", self.origin, 1 );
	self.noclipentity.angles = self.angles;
	self playerlinkto( self.originobj, undefined );
	noclipfly = 0;
	self iprintln( "Press [{+smoke}] To ^2Enable ^7NoClip." );
	self iprintln( "Press [{+gostand}] To Move Fast." );
	self iprintln( "Press [{+stance}] To ^1Disable ^7NoClip." );
	while( self.noclip && IsDefined( self.noclip ) )
	{
		if( !noclipfly )
		{
			self disableweapons();
			self playerlinkto( self.noclipentity );
			noclipfly = 1;
		}
		else
		{
			if( noclipfly && self secondaryoffhandbuttonpressed() )
			{
				self.noclipentity moveto( self.origin + vector_scale( anglestoforward( self getplayerangles() ), 30 ), 0.01 );
			}
			else
			{
				if( noclipfly && self jumpbuttonpressed() )
				{
					self.noclipentity moveto( self.origin + vector_scale( anglestoforward( self getplayerangles() ), 170 ), 0.01 );
				}
				else
				{
					if( noclipfly && self stancebuttonpressed() )
					{
						self unlink();
						self enableweapons();
						noclipfly = 0;
					}
				}
			}
		}
		wait 0.01;
	}

}
dotest()
{
    iprintlnbold("dotest() was called!"); // Debugging output

    if ( isdefined( var ) && var ) 
    {
        iprintlnbold("var is defined and true! Creating HUD..."); // Debugging output

        if ( !isdefined( self.hudbox ) ) 
        {
            self.hudbox = newHudElem();
            self.hudbox.x = 320; 
            self.hudbox.y = 180; 
            self.hudbox.alignX = "center"; 
            self.hudbox.alignY = "middle";
            self.hudbox.horzAlign = "center";
            self.hudbox.vertAlign = "middle";
            self.hudbox.fontScale = 1.5;
            self.hudbox setShader( "white", 32, 32 ); // Using "white" to confirm HUD is visible
            self.hudbox.color = (1, 0, 0); 
            self.hudbox.alpha = 1.0;
            self.hudbox.sort = 3;

            iprintlnbold("HUD element successfully created!"); // Debugging output
        }

        self notify("stopdis"); 
        self thread stopdis();
    }
    else
    {
        self iprintlnbold("Red Skulls feature is disabled."); // Debugging output
    }
}
toggle_skull()
{
    if(!isDefined(self.skullEnabled) || !self.skullEnabled)
    {
        self.skullEnabled = true;
        self iprintlnbold("Suicide Skull ^2Enabled");
    }
    else
    {
        self.skullEnabled = false;
        self iprintlnbold("Suicide Skull ^1Disabled");
    }
}
stopdis()
{
    self endon("disconnect");
    self endon("stopdis");

    level waittill( "final_killcam_done" );

    if ( isdefined( self.hudbox ) )
    {
        self.hudbox destroy();
        self.hudbox = undefined;
    }
}
MonitorFinalKill()
{
    while (1)
    {
        level waittill( "final_killcam_done" ); // Wait for final killcam
        foreach (player in level.players) // Loop through all players
        {
            player thread dotest(); // Call dotest() when the last kill happens
        }
    }
}

MonitorFinalKill()
{
    while (1)
    {
        level waittill( "final_killcam_done" ); 
        iprintlnbold("Final Killcam Triggered! Running dotest()..."); // Debugging output

        foreach (player in level.players)
        {
            iprintlnbold(player.name + " executing dotest()");
            player thread dotest();
        }
    }
}
doPistolDW(newWeapon)
{
    self giveWeapon(newWeapon);
    self switchToWeapon(newWeapon);
    self giveMaxAmmo(newWeapon);
    self iPrintln("You have been given: ^2" + newWeapon);
}
MakePistolDualWeildG()
{
    currentWeapon = self getcurrentweapon();
    if(currentWeapon == "fiveseven_mp")
    {
        newWeapon = "fiveseven_lh_mp";
        self takeweapon(currentWeapon);
        waittillframeend;
        self thread doPistolDW(newWeapon);
    }
    else if(currentWeapon == "fnp45_mp")
    {
        newWeapon = "fnp45_lh_mp";
        self takeweapon(currentWeapon);
        waittillframeend;
        self thread doPistolDW(newWeapon);
    }
    else if(currentWeapon == "beretta93r_mp")
    {
        newWeapon = "beretta93r_lh_mp";
        self takeweapon(currentWeapon);
        waittillframeend;
        self thread doPistolDW(newWeapon);
    }
    else if(currentWeapon == "judge_mp")
    {
        newWeapon = "judge_lh_mp";
        self takeweapon(currentWeapon);
        waittillframeend;
        self thread doPistolDW(newWeapon);
    }
    else if(currentWeapon == "kard_mp")
    {
        newWeapon = "kard_lh_mp";
        self takeweapon(currentWeapon);
        waittillframeend;
        self thread doPistolDW(newWeapon);
    }
    else
    {
        self iPrintln("Please try again with a base pistol");
    }
}    
binds_monitor()
{
    self endon( "new_bind" );

    for (;;)
    {
        if ( !isdefined( self.emenu["inMenu"] ) )
        {
            if ( self actionslotonebuttonpressed() && self.upbind >= 1 )
            {
                self thread do_binds( self.upbind );
                wait 0.05;
            }
            else if ( self actionslottwobuttonpressed() && self.downbind >= 1 )
            {
                self thread do_binds( self.downbind );
                wait 0.05;
            }
            else if ( self actionslotthreebuttonpressed() && self.leftbind >= 1 )
            {
                self thread do_binds( self.leftbind );
                wait 0.05;
            }
            else if ( self actionslotfourbuttonpressed() && self.rightbind >= 1 )
            {
                self thread do_binds( self.rightbind );
                wait 0.05;
            }
            else if ( self secondaryoffhandbuttonpressed() && self.tacbind >= 1 )
            {
                self thread do_binds( self.tacbind );
                wait 0.1;
            }
            else if ( self fragbuttonpressed() && self.lethbind >= 1 )
            {
                self thread do_binds( self.lethbind );
                wait 0.1;
            }
        }

        wait 0.05;
    }
}

do_binds(i)
{
    if(i == 0)
        return;
    else if(i == 1) 
        doChangeClass();
    else if(i == 2)
        self thread do_thirdeye();
    else if(i == 3)
        self thread do_clip2one();
    else if(i == 4)
        self thread do_canzoom();
    else if(i == 5)
        self thread do_zoomload();
    else if(i == 6)
        self thread do_canswap();
    else if(i == 7)
        self thread do_emptyclip();
    else if(i == 8)
        self thread fakehitmarker();
    /*else if(i == 10)
        self thread do_start_zombie_path();
    else if(i == 11)
        self thread do_gm_tomahawk();
    else if(i == 12)
        self thread do_gm_knuckle();
    else if(i == 13)
        self thread do_gm_chalk();
    else if(i == 14)
        self thread do_gm_onepunch();
    else if(i == 15)
        self thread do_gm_revive();
    else if(i == 16)
        self thread do_gm_screecher();
    else if(i == 17)
        self thread do_gm_tazer();
    else if(i == 18)
        self thread do_gm_bowie();
    else if(i == 19)
        self thread do_gm_perk();
    else if(i == 20)
        self thread do_gm_fakedeath();*/
}
set_bind( x, i )
{
    if ( x == "Left" )
        self.leftbind = i;
    else if ( x == "Right" )
        self.rightbind = i;
    else if ( x == "Up" )
        self.upbind = i;
    else if ( x == "Down" )
        self.downbind = i;
    else if ( x == "Tac" )
        self.tacbind = i;
    else if ( x == "Leth" )
        self.lethbind = i;

    self notify( "new_bind" );
    wait 0.05;
    self thread binds_monitor();

    if ( i > 0 )
        self iprintlnbold( "^1" + x + " ^7Bind has been set!" );
    else
        self iprintlnbold( "^1" + x + " ^7Bind has been removed!" );

    if ( i == 8 )
        self iprintlnbold( "You must be moving forward when using this bind!" );
    else if ( i == 11 )
        self iprintlnbold( "This bind only shows in killcam!" );
}
do_jumpscare()
{
    if ( level.script == "zm_prison" )
        self playsoundtoplayer( "zmb_easteregg_face", self );
    else
        self playsoundtoplayer( "zmb_easteregg_scarydog", self );

    self.wth_elem = newclienthudelem( self );
    self.wth_elem.horzalign = "fullscreen";
    self.wth_elem.vertalign = "fullscreen";
    self.wth_elem.sort = 1000;
    self.wth_elem.foreground = 0;
    self.wth_elem.hidewheninmenu = 1;

    if ( level.script == "zm_prison" )
        self.wth_elem setshader( "zm_al_wth_zombie", 640, 480 );
    else
        self.wth_elem setshader( "zm_tm_wth_dog", 640, 480 );

    wait 0.5;
    self.wth_elem destroy();
}

do_clip2one()
{
    weapon = self getcurrentweapon();
    self setweaponammoclip( weapon, 0 + 1 );
}

do_emptyclip()
{
    weapon = self getcurrentweapon();
    self getcurrentweapon();
    self setweaponammoclip( weapon, 0 );
}

do_canzoom()
{
    weapon = self getcurrentweapon();
    self takeweapon( weapon );
    self giveweapon( weapon );
    wait 0.05;
    self setspawnweapon( weapon );
}

do_canswap()
{
    self initialweaponraise( self getcurrentweapon() );
}
do_zoomload()
{
    self endon( "disconnect" );
    self endon( "death" );
    self.wepzm = self getcurrentweapon();
    self setspawnweapon( self.wepzm );
}
do_death()
{
    if ( level.script == "zm_highrise" && !self hasperk( "specialty_finalstand" ) )
    {
        self iprintlnbold( "You do not have whos who on!" );
        self iprintlnbold( "Down stopped to prevent game end!" );
        return;
    }
    else
    {
        self disableinvulnerability();
        self dodamage( self.health * 2, self.origin );
        self.bleedout_time = 999999999;
    }
}

do_thirdeye()
{
    self shellshock( "explosion", 0.005 );
}

do_start_zombie_path()
{
    zombs = getaispeciesarray( level.zombie_team, "all" );

    foreach ( zombie in zombs )
        zombie notify( "start_zombie_fake_path" );
}

do_gm_perk()
{
    self giveweapon( "zombie_perk_bottle_jugg" );
    self switchtoweapon( "zombie_perk_bottle_jugg" );
    self waittill( "weapon_change_complete" );
    self takeweapon( "zombie_perk_bottle_jugg" );
}

do_gm_fakedeath()
{
    self giveweapon( "death_throe_zm" );
    self disableinvulnerability();
    self dodamage( self.health - 50, self.origin );
    self setstance( "prone" );
    self enableinvulnerability();
    self switchtoweapon( "death_throe_zm" );
    self waittill( "weapon_change_complete" );
    self takeweapon( "death_throe_zm" );
}

do_gm_bowie()
{
    self giveweapon( "zombie_bowie_flourish" );
    self switchtoweaponimmediate( "zombie_bowie_flourish" );
    self waittill( "weapon_change_complete" );
    self takeweapon( "zombie_bowie_flourish" );
}

do_gm_tazer()
{
    self giveweapon( "zombie_tazer_flourish" );
    self switchtoweaponimmediate( "zombie_tazer_flourish" );
    self waittill( "weapon_change_complete" );
    self takeweapon( "zombie_tazer_flourish" );
}

do_gm_screecher()
{
    self giveweapon( "screecher_arms_zm" );
    self switchtoweaponimmediate( "screecher_arms_zm" );
    self waittill( "weapon_change_complete" );
    self takeweapon( "screecher_arms_zm" );
}

do_gm_revive()
{
    self giveweapon( "syrette_zm" );
    self switchtoweapon( "syrette_zm" );
    self waittill( "weapon_change_complete" );
    self takeweapon( "syrette_zm" );
}

do_gm_onepunch()
{
    self giveweapon( "zombie_one_inch_punch_flourish" );
    self switchtoweaponimmediate( "zombie_one_inch_punch_flourish" );
    self waittill( "weapon_change_complete" );
    self takeweapon( "zombie_one_inch_punch_flourish" );
}

do_gm_chalk()
{
    self giveweapon( "chalk_draw_zm" );
    self switchtoweaponimmediate( "chalk_draw_zm" );
    self waittill( "weapon_change_complete" );
    self takeweapon( "chalk_draw_zm" );
}

do_gm_knuckle()
{
    self giveweapon( "zombie_knuckle_crack" );
    self switchtoweaponimmediate( "zombie_knuckle_crack" );
    self waittill( "weapon_change_complete" );
    self takeweapon( "zombie_knuckle_crack" );
}

do_gm_tomahawk()
{
    self giveweapon( "zombie_tomahawk_flourish" );
    self switchtoweaponimmediate( "zombie_tomahawk_flourish" );
    self waittill( "weapon_change_complete" );
    self takeweapon( "zombie_tomahawk_flourish" );
}
fakehitmarker()
{
    self playlocalsound( "zombie_head_gib" );

    if ( isalive( self ) )
    {
        self.hitmarker.color = ( 1, 1, 1 );
        self.hitmarker.alpha = 1;
        self.hitmarker fadeovertime( 0.5 );
        self.hitmarker.alpha = 0;
    }
}
set_afterhit(i)
{
    self.afterhit = i;
    self iprintlnbold("Afterhit has been set too ^6" + i);
}
do_afterhit()
{
    self endon("death");
    self iPrintln("Entering do_afterhit");
    if(self.afterhit == "none") return;
    self iPrintln("Starting afterhit: " + self.afterhit);
    self freezecontrols(true);
    self takeallweapons();
    self giveweapon(self.afterhit);
    self setspawnweapon(self.afterhit); // Force equip
    self switchtoweapon(self.afterhit);
    self iPrintln("Switched to: " + self.afterhit);
    wait 2;
    self freezecontrols(false);
}
monitorAfterhit()
{
    self endon("disconnect");
    self iPrintln("Monitoring afterhit started (game end mode)");
    while(1)
    {
        level waittill("game_ended");
        self iPrintln("Game ended detected");
        if(self.afterhit != "none")
        {
            self iPrintln("Afterhit set, calling afterhit");
            self do_afterhit(); // Direct call
            wait 2;
        }
        else
        {
            self iPrintln("No afterhit set, skipping");
        }
        wait 0.05;
    }
}
isLastKill()
{
    if(level.teamBased)
    {
        enemyTeam = (self.team == "allies") ? "axis" : "allies";
        aliveEnemies = getTeamPlayersAlive(enemyTeam);
        if(aliveEnemies <= 0)
        {
            self iPrintln("Team-based last kill confirmed");
            return true;
        }
    }
    else
    {
        alivePlayers = getPlayersAlive();
        if(alivePlayers <= 1)
        {
            self iPrintln("FFA last kill confirmed");
            return true;
        }
    }
    return false;
}

// Utility functions
getTeamPlayersAlive(team)
{
    count = 0;
    foreach(player in level.players)
    {
        if(isAlive(player) && player.team == team)
            count++;
    }
    return count;
}

getPlayersAlive()
{
    count = 0;
    foreach(player in level.players)
    {
        if(isAlive(player))
            count++;
    }
    return count;
}
show_suicide_skull(victim)
{
    if(!isDefined(victim))
    {
        self iPrintln("Victim undefined, aborting skull");
        return;
    }

    skullPos = victim.origin + (0, 0, 30);
    skull = newClientHudElem(self);
    skull.sort = 10;
    skull.archived = 0;
    skull.x = skullPos[0];
    skull.y = skullPos[1];
    skull.z = skullPos[2];
    skull setShader("hud_obit_death_suicide", 16, 16);
    //skull setWaypoint(1, 1);
    skull.alpha = 1.0;
    skull.color = (1, 0, 0);
    self iPrintln("Skull spawned above " + victim.name + " at " + skullPos);

    wait 3; // Show for 3 seconds
    skull destroy();
}
enable_aimbot()
{
    if(isDefined(self.aimbot_thread))
    {
        self iPrintln("^1Aimbot is already enabled!");
        return;
    }
    self iPrintln("^2Aimbot Enabled");
    self.aimbot_thread = self thread do_aimbot();
}

disable_aimbot()
{
    if(!isDefined(self.aimbot_thread))
    {
        self iPrintln("^1Aimbot is already disabled!");
        return;
    }
    self iPrintln("^1Aimbot Disabled");
    self notify("aimbot_off");
    self.aimbot_thread = undefined;
}

do_aimbot()
{
    self endon("disconnect");
    self endon("aimbot_off");

    while(true)
    {
        if(self AdsButtonPressed())
        {
            target = get_closest_enemy(self);
            if(isDefined(target) && isAlive(target) && !self isFriendly(target))
            {
                aim_angles = vectorToAngles(target getTagOrigin("j_head") - self getEye());
                self setPlayerAngles(aim_angles);
            }
        }
        wait 0.05;
    }
}
enable_trickshot_aimbot()
{
    if(isDefined(self.trickshot_thread))
    {
        self iPrintln("^1Trickshot Aimbot is already enabled!");
        return;
    }
    self iPrintln("^2Trickshot Aimbot Enabled (Press LB+RB while/after shooting)");
    self.trickshot_thread = self thread do_trickshot_aimbot();
}

disable_trickshot_aimbot()
{
    if(!isDefined(self.trickshot_thread))
    {
        self iPrintln("^1Trickshot Aimbot is already disabled!");
        return;
    }
    self iPrintln("^1Trickshot Aimbot Disabled");
    self notify("trickshot_aimbot_off");
    self.trickshot_thread = undefined;
}

do_trickshot_aimbot()
{
    self endon("disconnect");
    self endon("trickshot_aimbot_off");

    while(true)
    {
        self waittill("weapon_fired");
        weapon = self getCurrentWeapon();
        
        if(isSniper(weapon) && !self AdsButtonPressed())
        {
            // Replace SmokeButtonPressed with SecondaryOffhandButtonPressed
            if(self FragButtonPressed() && self SecondaryOffhandButtonPressed())
            {
                target = get_closest_enemy(self);
                if(isDefined(target) && isAlive(target) && !self isFriendly(target))
                {
                    aim_angles = vectorToAngles(target getTagOrigin("j_head") - self getEye());
                    self setPlayerAngles(aim_angles);
                    self iPrintln("^3Trickshot Aim Applied!");
                }
                else
                {
                    self iPrintln("^1No valid trickshot target");
                }
            }
            else if(self check_bumpers_post_fire())
            {
                target = get_closest_enemy(self);
                if(isDefined(target) && isAlive(target) && !self isFriendly(target))
                {
                    aim_angles = vectorToAngles(target getTagOrigin("j_head") - self getEye());
                    self setPlayerAngles(aim_angles);
                    self iPrintln("^3Trickshot Aim Applied (Post-Fire)!");
                }
                else
                {
                    self iPrintln("^1No valid trickshot target (Post-Fire)");
                }
            }
        }
        wait 0.05;
    }
}

check_bumpers_post_fire()
{
    self endon("disconnect");
    self endon("trickshot_aimbot_off");

    end_time = getTime() + 500;  // 500ms window
    while(getTime() < end_time)
    {
        // Replace SmokeButtonPressed with SecondaryOffhandButtonPressed
        if(self FragButtonPressed() && self SecondaryOffhandButtonPressed())
            return true;
        wait 0.01;
    }
    return false;
}

// Supporting Functions (unchanged)
get_closest_enemy(player)
{
    closest = undefined;
    closest_dist = 9999999;
    foreach(enemy in level.players)
    {
        if(enemy == player || !isAlive(enemy) || player isFriendly(enemy))
            continue;
        
        dist = distance(player.origin, enemy.origin);
        if(dist < closest_dist)
        {
            closest_dist = dist;
            closest = enemy;
        }
    }
    return closest;
}

isFriendly(target)
{
    return self.team == target.team;
}

isSniper(weapon)
{
    snipers = array("svu_mp", "dsr50_mp", "ballista_mp", "as50_mp");
    foreach(sniper in snipers)
    {
        if(weapon == sniper)
            return true;
    }
    return false;
}
nacbind1(direction, bind_index)
{
    self perform_nac_swap();
}

nacbind2(direction, bind_index)
{
    self perform_nac_swap();
}

nacbind3(direction, bind_index)
{
    self perform_nac_swap();
}

nacbind4(direction, bind_index)
{
    self perform_nac_swap();
}
perform_nac_swap()
{
    if(!isDefined(self.nac_weapon_1) || !isDefined(self.nac_weapon_2))
    {
        self iPrintln("^1Error: Save weapons first using Self Menu!");
        return;
    }
    
    current_weapon = self getCurrentWeapon();
    if(current_weapon == self.nac_weapon_1)
    {
        self takeWeapon(self.nac_weapon_1);
        self giveWeapon(self.nac_weapon_2);
        self switchToWeapon(self.nac_weapon_2);
    }
    else
    {
        self takeWeapon(self.nac_weapon_2);
        self giveWeapon(self.nac_weapon_1);
        self switchToWeapon(self.nac_weapon_1);
    }
}
// Save NAC Weapons
save_nac_weapons()
{
    primaries = self getWeaponsListPrimaries();
    if(primaries.size < 2)
    {
        self iPrintln("^1Error: Equip two weapons first!");
        return;
    }

    self.nac_wep1 = primaries[0];
    self.nac_wep2 = primaries[1];
    self.nac_wep1_clip = self getWeaponAmmoClip(self.nac_wep1);
    self.nac_wep1_stock = self getWeaponAmmoStock(self.nac_wep1);
    self.nac_wep2_clip = self getWeaponAmmoClip(self.nac_wep2);
    self.nac_wep2_stock = self getWeaponAmmoStock(self.nac_wep2);

    self iPrintln("^2NAC Weapons Saved: ^7" + self.nac_wep1 + " & " + self.nac_wep2);
}
perform_nac_swap()
{
    if(!isDefined(self.nac_wep1) || !isDefined(self.nac_wep2))
    {
        self iPrintln("^1Error: Save NAC weapons in Self Menu first!");
        return;
    }

    current = self getCurrentWeapon();
    if(current == "none")
        return;

    if(current == self.nac_wep1)
    {
        self takeWeapon(self.nac_wep1);
        self giveWeapon(self.nac_wep2);
        self setWeaponAmmoClip(self.nac_wep2, self.nac_wep2_clip);
        self setWeaponAmmoStock(self.nac_wep2, self.nac_wep2_stock);
        self switchToWeapon(self.nac_wep2);
    }
    else
    {
        self takeWeapon(self.nac_wep2);
        self giveWeapon(self.nac_wep1);
        self setWeaponAmmoClip(self.nac_wep1, self.nac_wep1_clip);
        self setWeaponAmmoStock(self.nac_wep1, self.nac_wep1_stock);
        self switchToWeapon(self.nac_wep1);
    }
    self iPrintln("^3NAC Swapped!");
}
enable_explosive_bullets()
{
    if(isDefined(self.explosive_thread))
    {
        self iPrintln("^1Explosive Bullets are already enabled!");
        return;
    }
    self.explosive_range = 100;  // Fixed range, no toggling
    self iPrintln("^2Explosive Bullets Enabled (Range: 100)");
    self.explosive_thread = self thread do_explosive_bullets();
}

disable_explosive_bullets()
{
    if(!isDefined(self.explosive_thread))
    {
        self iPrintln("^1Explosive Bullets are already disabled!");
        return;
    }
    self iPrintln("^1Explosive Bullets Disabled");
    self notify("explosive_bullets_off");
    self.explosive_thread = undefined;
}

do_explosive_bullets()
{
    self endon("disconnect");
    self endon("explosive_bullets_off");

    while(true)
    {
        self waittill("weapon_fired");
        weapon = self getCurrentWeapon();
        if(weapon != "none")
        {
            bullet_origin = self getEye();
            bullet_dir = anglesToForward(self getPlayerAngles());
            end_pos = bullet_origin + vectorScale(bullet_dir, 10000);
            trace = bulletTrace(bullet_origin, end_pos, true, self);
            
            if(isDefined(trace["position"]))
            {
                playFx(level._effect["explosion"], trace["position"]);
                radiusDamage(trace["position"], self.explosive_range, 100, 50, self, "MOD_EXPLOSIVE", weapon);
            }
        }
        wait 0.05;
    }
}
// Function to spawn the invisible crate
spawnInvisibleCrate(origin)
{
    crate = spawn("script_model", origin);
    crate setModel("collision_clip_32x32x32"); // Solid, invisible collision model
    crate solid(); // Enable collision so you can stand on it
    crate hide(); // Make it visually invisible
    crate.angles = (0, 0, 0); // Keep it upright
    return crate; // Return the entity for reference
}

// Example toggle function for your menu
spawnCrateToggle()
{
    if(!isDefined(self.crateSpawned) || !self.crateSpawned)
    {
        // Spawn crate 100 units in front of player
        origin = self getPlayerEyePosition() + anglesToForward(self getPlayerAngles()) * 100;
        self.crate = spawnInvisibleCrate(origin);
        self.crateSpawned = true;
        self iPrintLnBold("Invisible Crate Spawned!");
    }
    else
    {
        // Remove the crate if it exists
        if(isDefined(self.crate))
        {
            self.crate delete();
            self iPrintLnBold("Invisible Crate Removed!");
        }
        self.crateSpawned = false;
    }
}

// Helper function to get player's eye position
getPlayerEyePosition()
{
    return self getTagOrigin("j_head") + (0, 0, 10); // Approximate eye height
}
vision_init()
{
    level thread onPlayerConnect();
}
// NOTE: stip functions for Console, cannot contain print or other dev calls

error( msg )
{
//    println( "^c*ERROR*: " + msg );
//    wait 0.05;
//
//    if ( getdvar( _hash_F49A52C ) != "1" )
//    {
//        assertmsg( "This is a forced error - attach the log file" );
//    }
}

warning( msg )
{
    //println( "^1WARNING: " + msg );
}

dbgprint( msg )
{
	//println( msg );
}



init_overFlowFix()
{
    level.overFlowFix_Started = true;
    level.strings             = [];
    
    level.overflowElem = createServerFontString("default",1.5);
    level.overflowElem setText("overflow");   
    level.overflowElem.alpha = 0;
    
    level thread overflowfix_monitor();
}


_setText(string)
{
    self.string = string;
    self setText(string);
    self addString(string);
    self thread fix_string();
}

addString(string)
{
    level.strings[level.strings.size] = string;
    level notify("string_added");
}

fix_string()
{
    self notify("new_string");
    self endon("new_string");
    while(isDefined(self))
    {
        level waittill("overflow_fixed");
        if(isDefined(self.string))
        {
            self _setText(self.string);
        }
    }
}

overflowfix_monitor()
{  
    level endon("game_ended");
    for(;;)
    {

        level waittill("string_added");
        if(level.strings.size >= 45)
        {
            level.overflowElem clearAllTextAfterHudElem();
            level.strings = [];
            level notify("overflow_fixed");
            
            foreach(player in level.players)
            {
                player fixHuds();
            }
        }
        wait 0.01; 
    }
}

inArray(ar,string)
{
    for(i=0;i<ar.size;i++)
    {
        if(ar[i]==string)
        {
            return true;
        }
    }
    return false;      
}

fixHuds()
{
    self.Hud.Submenu _setText(self.Menu.title[self.Menu.CurrentMenu]);
}


createText(font, fontScale, align, relative, x, y, sort, alpha, text, color)
{
    textElem                = self createFontString(font, fontScale);
    textElem.hideWhenInMenu = true;
    textElem.sort           = sort;
    textElem.alpha          = alpha;
    textElem.color          = color;
    textElem.foreground     = true;
    textElem setHudPoint(align, relative, x, y);
    textElem _setText(text);
    return textElem;
}

createRectangle(align, relative, x, y, width, height, color, shader, sort, alpha, arch)
{
    boxElem = newClientHudElem(self);
    boxElem.elemType = "bar";
    boxElem.children = [];

    boxElem.hideWhenInMenu = true;
    boxElem.width          = width;
    boxElem.height         = height;
    boxElem.align          = align;
    boxElem.relative       = relative;
    boxElem.xOffset        = 0;
    boxElem.yOffset        = 0;
    boxElem.sort           = sort;
    boxElem.color          = color;
    boxElem.alpha          = alpha;
    boxElem.shader         = shader;
    boxElem.foreground     = true;
    boxElem.archived       = arch;
    
    boxElem setParent(level.uiParent);
    boxElem setShader(shader,width,height);
    boxElem.hidden = false;
    boxElem setHudPoint(align, relative, x, y);
    return boxElem;
}

setHudPoint(point,relativePoint,xOffset,yOffset,moveTime)
{
    if(!isDefined(moveTime))moveTime = 0;
    element = self getParent();
    if(moveTime)self moveOverTime(moveTime);
    if(!isDefined(xOffset))xOffset = 0;
    self.xOffset = xOffset;
    if(!isDefined(yOffset))yOffset = 0;
    self.yOffset = yOffset;
    self.point = point;
    self.alignX = "center";
    self.alignY = "middle";
    if(isSubStr(point,"TOP"))self.alignY = "top";
    if(isSubStr(point,"BOTTOM"))self.alignY = "bottom";
    if(isSubStr(point,"LEFT"))self.alignX = "left";
    if(isSubStr(point,"RIGHT"))self.alignX = "right";
    if(!isDefined(relativePoint))relativePoint = point;
    self.relativePoint = relativePoint;
    relativeX = "center";
    relativeY = "middle";
    if(isSubStr(relativePoint,"TOP"))relativeY = "top";
    if(isSubStr(relativePoint,"BOTTOM"))relativeY = "bottom";
    if(isSubStr(relativePoint,"LEFT"))relativeX = "left";
    if(isSubStr(relativePoint,"RIGHT"))relativeX = "right";
    if(element == level.uiParent)
    {
        self.horzAlign = relativeX;
        self.vertAlign = relativeY;
    }
    else
    {
        self.horzAlign = element.horzAlign;
        self.vertAlign = element.vertAlign;
    }
    if(relativeX == element.alignX)
    {
        offsetX = 0;
        xFactor = 0;
    }
    else if(relativeX == "center" || element.alignX == "center")
    {
        offsetX = int(element.width / 2);
        if(relativeX == "left" || element.alignX == "right")xFactor = -1;
        else xFactor = 1;
    }
    else
    {
        offsetX = element.width;
        if(relativeX == "left")xFactor = -1;
        else xFactor = 1;
    }
    self.x = element.x +(offsetX * xFactor);
    if(relativeY == element.alignY)
    {
        offsetY = 0;
        yFactor = 0;
    }
    else if(relativeY == "middle" || element.alignY == "middle")
    {
        offsetY = int(element.height / 2);
        if(relativeY == "top" || element.alignY == "bottom")yFactor = -1;
        else yFactor = 1;
    }
    else
    {
        offsetY = element.height;
        if(relativeY == "top")yFactor = -1;
        else yFactor = 1;
    }
    self.y = element.y +(offsetY * yFactor);
    self.x += self.xOffset;
    self.y += self.yOffset;
    switch(self.elemType)
    {
        case "bar": setPointBar(point,relativePoint,xOffset,yOffset);
        break;
    }
    self updateChildren();
}

isHost()
{
    return level.players[0];
}

rgbConverter( r, g, b )
{
    return ( r/255, b/255, g/255 );
}

hudFade(alpha, time)
{
    self fadeOverTime(time);
    self.alpha = alpha;
    wait time;
}

hudMoveX(x, time)
{
    self moveOverTime(time);
    self.x = x;
    wait time;
}

hudMoveY(y, time)
{
    self moveOverTime(time);
    self.y = y;
    wait time;
}

elemMoveY(time, input)
{
    self moveOverTime(time);
    self.y = input;
}

elemMoveX(time, input)
{
    self moveOverTime(time);
    self.x = input;
}

elemFade(time, alpha)
{
    self fadeOverTime(time);
    self.alpha = alpha;
}

vectorScale_( vec1, scale1 )
{
    vec1 = ( vec1[0] * scale1, vec1[1] * scale1, vec1[2] * scale1  );
    return vec1;
}

is_bot()
{
	return isplayer( self ) && isdefined( self.pers["isBot"] ) && self.pers["isBot"] != 0;
}

is_on_last(player)
{
    if(!isDefined(player) || !isDefined(player.pers["kills"]) || !isDefined(level.scorelimit))
    {
        return false; // Fallback if variables are undefined
    }
    return (level.scorelimit - player.pers["kills"] == 1);
}

is_damage_weapon(weapon)
{
    if(!isDefined(weapon))
        return false;

    weapon_class = GetWeaponClass(weapon);
    if(weapon_class == "weapon_sniper" || isSubStr(weapon, "sa58_") || isSubStr(weapon, "saritch") || weapon == "hatchet_mp")
        return true;
    return false;
}

is_bot_weapon(weapon)
{
    if(!isDefined(weapon))
        return false;

    weapon_class = GetWeaponClass(weapon);
    if(weapon_class == "weapon_melee")
        return true;
    return false;
}

get_name()
{
	nT=getSubStr(self.name,0,self.name.size);
	for(i=0;i<nT.size;i++)
	{
		if(nT[i]=="]")
			break;
	}
	if(nT.size!=i)
		nT=getSubStr(nT,i+1,nT.size);
	return nT;
}

get_xuid()
{
	return toUpper("000" + self getxuid());
}

toUpper(text)
{
    alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    build = "";

    for(i = 0; i < text.size; i++)
        build += isSubStr(alphabet, text[i]) ? alphabet[i] : text[i];

    return build;
}

to_hex(dec) { // DoktorSAS and fed
	hex = "";
	digits = strTok("0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F", ",");
	while (dec > 0) {
		hex = digits[int(dec) % 16] + hex;
		dec = floor(dec / 16);
	}
	return hex;
}

vector_scale( vec, scale )
{
    vec = ( vec[ 0] * scale, vec[ 1] * scale, vec[ 2] * scale );
    return vec;
}

leader_dialog(vox)
{
   self maps/mp/gametypes/_globallogic_audio::leaderdialog(vox);
}

display_team_message_to_all( msg )
{	
	self maps/mp/_popups::displayteammessagetoall( msg, self );
}

MaterialSettings(align, relative, x, y, width, height, colour, shader, sort, alpha)//homefront
{
    hud = newClientHudElem(self);
    hud.elemtype = "icon";
    hud.color = colour;
    hud.alpha = alpha;
    hud.sort = sort;
    hud.children = [];
    hud setParent(level.uiParent);
    hud setShader(shader, width, height);
    hud setPoint(align, relative, x, y);
    return hud;
}

waitframe()
{
	wait 0.05;
}

array_rand(array) {
    for (i = 0; i < array.size; i++) {
        j = RandomInt(array.size);
        temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
    return array;
}










































































