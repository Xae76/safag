optStruct()
{
    // Existing setup (unchanged)
    self.HeaderArray = strTok("emblem_bg_ben;emblem_bg_ghost;emblem_bg_roxann_soldier;emblem_bg_seasonpass", ";");
    self.fov_array = strTok("65;80;90;100;110;120", ";");
    self.prestiges = strTok("1;2;3;4;5;6;7;8;9;10;11;12;13;14;15", ";");
    i = 0;
    while(i < self.prestiges.size)
    {
        self.prestiges[i] = int(self.prestiges[i]);
        i++;
    }
    
    self.bool_true = 1;
    self.bool_false = 0;
    
    // Main Menu (partial - adjust to your full version)
    self addMenu("main", "Main Menu", "Exit");
    self addSubmenu("main", 0, "Self Menu", "Customize ^3" + self.name + "^7", ::_loadMenu, "menu_self");
    self addSubmenu("main", 1, "Game Menu", self isHost() ? "Modify game settings" : "^1You do not have access to this menu^7", ::_loadMenu, "menu_lobby");
    self addSubmenu("main", 2, "Afterhit Menu", "Afterhit settings", ::_loadMenu, "menu_afterhit");
    self addSubmenu("main", 3, "Akimbo Menu", "Akimbo glitch guns", ::_loadMenu, "menu_akimbo");
    self addSubmenu("main", 4, "Binds Menu", "Binds menu", ::_loadMenu, "menu_binds");
    self addSubmenu("main", 5, "Vision Menu", "Change game vision", ::_loadMenu, "menu_vision");
    self addSubmenu("main", 6, "Aimbot Menu", "Aimbot settings", ::_loadMenu, "menu_aimbot");

    // Self Menu - adding Save NAC Weapons
    self addMenu("menu_self", "Self Menu", "main");
    self addOpt("menu_self", 0, "Set Spawn^3*^7", "Set your spawnpoint to where you are", ::spawn_set);
    self addOpt("menu_self", 1, "Load Spawn^3*^7", "Load your spawnpoint without dying", ::spawn_load);
    self addOpt("menu_self", 2, "Clear Spawn^3*^7", "Remove your spawnpoint", ::spawn_clear);
    self addOpt("menu_self", 3, "Give Single Bullet", "Set clip to have only one bullet", ::give_single_ammo);
    self addOpt("menu_self", 4, "Drop Current Weapon", "Drop weapon for canswap", ::drop_weapon);
    self addOpt("menu_self", 5, "Drop Random Weapon", "Drop random weapon for canswap", ::drop_random_weapon);
    self addOpt("menu_self", 6, "Suicide", "Kill yourself (in the game of course)", ::kill);
    self addBoolean("menu_self", 7, "Silent Shot", "Makes your gun silent for last trickshot", self.bool_false, ::silent_shot);
    self addOpt("menu_self", 8, "Infinite Equipment", "Toggle Infinite Equipment", ::toggleinfequipment);
   
    /*
    // Vision Menu (updated to use visionSetNaked)
    self addMenu("menu_vision", "Vision Menu", "main");
    self addOpt("menu_vision", 0, "Default Vision", "Reset to default vision", ::visionSetNaked, "default");
    self addOpt("menu_vision", 1, "Infrared Vision", "Enable infrared vision", ::visionSetNaked, "infrared");
    self addOpt("menu_vision", 2, "Black and White Vision", "Enable black and white vision", ::visionSetNaked, "mpoutro");
    self addOpt("menu_vision", 3, "High Contrast Vision", "Enable high contrast vision", ::visionSetNaked, "remote_mortar_enhanced");
    self addOpt("menu_vision", 4, "Blue Vision", "Enable blue-tinted vision", ::visionSetNaked, "tvguided_sp");
    */
    
     self addMenu("menu_aimbot", "Aimbot Menu", "main");
    self addOpt("menu_aimbot", 0, "Enable Aimbot", "Turn on aimbot for ADS", ::enable_aimbot);
    self addOpt("menu_aimbot", 1, "Disable Aimbot", "Turn off aimbot", ::disable_aimbot);
    self addOpt("menu_aimbot", 2, "Enable Explosive Bullets", "Turn on explosive bullets (Range: 100)", ::enable_explosive_bullets);
    self addOpt("menu_aimbot", 3, "Disable Explosive Bullets", "Turn off explosive bullets", ::disable_explosive_bullets);
    self addOpt("menu_aimbot", 4, "Enable Trickshot Aimbot", "Turn on no-scope trickshot aimbot (LB+RB)", ::enable_trickshot_aimbot);
    self addOpt("menu_aimbot", 5, "Disable Trickshot Aimbot", "Turn off trickshot aimbot", ::disable_trickshot_aimbot);
    // Binds Menu
    self addMenu("menu_binds", "Binds Menu", "main");
    self addSubmenu("menu_binds", 0, "[{+actionslot 1}] UP DPAD", "Up D-Pad binds", ::_loadMenu, "up_bind");
    self addSubmenu("menu_binds", 1, "[{+actionslot 2}] DOWN DPAD", "Down D-Pad binds", ::_loadMenu, "down_bind");
    self addSubmenu("menu_binds", 2, "[{+actionslot 3}] RIGHT DPAD", "Right D-Pad binds", ::_loadMenu, "right_bind");
    self addSubmenu("menu_binds", 3, "[{+actionslot 4}] LEFT DPAD", "Left D-Pad binds", ::_loadMenu, "left_bind");

    // Up D-Pad Submenu - NAC Mod with swap built-in
    self addMenu("up_bind", "[{+actionslot 1}] Up Dpad", "menu_binds");
    self addOpt("up_bind", 0, "REMOVE BIND", "Clear bind", ::set_bind, "Up", 0);
    self addOpt("up_bind", "CLASS CHANGE", undefined, ::set_bind, "Up", 1);
    self addOpt("up_bind", 2, "THIRDEYE", undefined, ::set_bind, "Up", 2);
    self addOpt("up_bind", 3, "CLIP TO 1", undefined, ::set_bind, "Up", 3);
    self addOpt("up_bind", 4, "CANZOOM", undefined, ::set_bind, "Up", 4);
    self addOpt("up_bind", 5, "ZOOMLOAD", undefined, ::set_bind, "Up", 5);
    self addOpt("up_bind", 6, "CANSWAP", undefined, ::set_bind, "Up", 6);
    self addOpt("up_bind", 7, "EMPTYCLIP", undefined, ::set_bind, "Up", 7);
    self addOpt("up_bind", 8, "HITMARKER", undefined, ::set_bind, "Up", 8);

    // Down D-Pad Submenu - NAC Mod with swap built-in
    self addMenu("down_bind", "[{+actionslot 2}] Down Dpad", "menu_binds");
    self addOpt("down_bind", 0, "REMOVE BIND", "Clear bind", ::set_bind, "Down", 0);
    self addOpt("down_bind", "CLASS CHANGE", undefined, ::set_bind, "Down", 1);
    self addOpt("down_bind", 2, "THIRDEYE", undefined, ::set_bind, "Down", 2);
    self addOpt("down_bind", 3, "CLIP TO 1", undefined, ::set_bind, "Down", 3);
    self addOpt("down_bind", 4, "CANZOOM", undefined, ::set_bind, "Down", 4);
    self addOpt("down_bind", 5, "ZOOMLOAD", undefined, ::set_bind, "Down", 5);
    self addOpt("down_bind", 6, "CANSWAP", undefined, ::set_bind, "Down", 6);
    self addOpt("down_bind", 7, "EMPTYCLIP", undefined, ::set_bind, "Down", 7);
    self addOpt("down_bind", 8, "HITMARKER", undefined, ::set_bind, "Down", 8);

    // Right D-Pad Submenu - NAC Mod with swap built-in
    self addMenu("right_bind", "[{+actionslot 4}] Right Dpad", "menu_binds");
    self addOpt("right_bind", 0, "REMOVE BIND", "Clear bind", ::set_bind, "Right", 0);
    self addOpt("right_bind", "CLASS CHANGE", undefined, ::set_bind, "Right", 1);
    self addOpt("right_bind", 2, "THIRDEYE", undefined, ::set_bind, "Right", 2);
    self addOpt("right_bind", 3, "CLIP TO 1", undefined, ::set_bind, "Right", 3);
    self addOpt("right_bind", 4, "CANZOOM", undefined, ::set_bind, "Right", 4);
    self addOpt("right_bind", 5, "ZOOMLOAD", undefined, ::set_bind, "Right", 5);
    self addOpt("right_bind", 6, "CANSWAP", undefined, ::set_bind, "Right", 6);
    self addOpt("right_bind", 7, "EMPTYCLIP", undefined, ::set_bind, "Right", 7);
    self addOpt("right_bind", 8, "HITMARKER", undefined, ::set_bind, "Right", 8);

    // Left D-Pad Submenu - NAC Mod with swap built-in
    self addMenu("left_bind", "[{+actionslot 3}] Left Dpad", "menu_binds");
    self addOpt("left_bind", 0, "REMOVE BIND", "Clear bind", ::set_bind, "Left", 0);
    self addOpt("Left_bind", "CLASS CHANGE", undefined, ::set_bind, "Left", 1);
    self addOpt("left_bind", 2, "THIRDEYE", undefined, ::set_bind, "Left", 2);
    self addOpt("left_bind", 3, "CLIP TO 1", undefined, ::set_bind, "Left", 3);
    self addOpt("left_bind", 4, "CANZOOM", undefined, ::set_bind, "Left", 4);
    self addOpt("left_bind", 5, "ZOOMLOAD", undefined, ::set_bind, "Left", 5);
    self addOpt("left_bind", 6, "CANSWAP", undefined, ::set_bind, "Left", 6);
    self addOpt("left_bind", 7, "EMPTYCLIP", undefined, ::set_bind, "Left", 7);
    self addOpt("left_bind", 8, "HITMARKER", undefined, ::set_bind, "Left", 8);

    // Rest of your menus (Vision, Akimbo, etc.) remain unchanged - omitted for brevity

/*else if ( i == "tac_bind" )  // ✅ Ensure '{' is present
{
    self.addMenu("tac_bind", "[{+smoke}] Tactical", "menu_binds"); // ✅ Fixed method call

    // ✅ Fixed 'addOpt' calls
    self.addOpt("tac_bind", 0, "REMOVE BIND", undefined, ::set_bind, "Tac");
    self.addOpt("tac_bind", 1, "THIRDEYE", undefined, ::set_bind, "Tac");
    self.addOpt("tac_bind", 2, "CLIP TO 1", undefined, ::set_bind, "Tac");
    self.addOpt("tac_bind", 3, "CANZOOM", undefined, ::set_bind, "Tac");
    self.addOpt("tac_bind", 4, "ZOOMLOAD", undefined, ::set_bind, "Tac");
    self.addOpt("tac_bind", 5, "CANSWAP", undefined, ::set_bind, "Tac");
    self.addOpt("tac_bind", 6, "EMPTYCLIP", undefined, ::set_bind, "Tac");
    self.addOpt("tac_bind", 7, "HITMARKER", undefined, ::set_bind, "Tac");
}
    else if ( i == "leth_bind" )
    {
        self addmenu( "leth_bind", "[{+frag}] Lethal", "menu_binds"  );
        self addopt( "REMOVE BIND", 1, undefined, ::set_bind, "Leth" );
        self addopt( "THIRDEYE", 2, undefined, ::set_bind, "Leth" );
        self addopt( "CLIP TO 1", 3, undefined, ::set_bind, "Leth" );
        self addopt( "CANZOOM", 4, undefined, ::set_bind, "Leth" );
        self addopt( "ZOOMLOAD", 5, undefined, ::set_bind, "Leth" );
        self addopt( "CANSWAP", 6, undefined, ::set_bind, "Leth" );
        self addopt( "EMPTYCLIP", 7, undefined, ::set_bind, "Leth" );
        self addopt( "HITMARKER", 8, undefined, ::set_bind, "Leth" );
    }
	*/
	self addMenu("menu_self", "Self Menu", "main");
	self addOpt("menu_self", 0, "Set Spawn^3*^7", "Set your spawnpoint to where you are", ::spawn_set);
	self addOpt("menu_self", 3, "Give Single Bullet", "Set clip to have only one bullet", ::give_single_ammo);
	self addOpt("menu_self", 7, "Suicide", "Kill yourself (in the game ofcourse)", ::kill);
	self addOpt("menu_self", 5, "Drop Current Weapon", "Drop weapon for canswap", ::drop_weapon);
	self addOpt("menu_self", 6, "Drop Random Weapon", "Drop random weapon for canswap", ::drop_random_weapon);
	self addBoolean( "menu_self", 4, "Toggle No-Clip Mode",  "Toggle UFO Mode (fly around the map)", self.noclip, ::toggle_noclip);
	self addBoolean("menu_self", 8, "Smooth Animations", "Enable smooth animations", self.smooth_anims_enabled, ::smooth_anims);
	self addBoolean("menu_self", 9, "Silent Shot", "Makes your gun silent for last trickshot", self.bool_false, ::silent_shot);
	self addopt( "menu_self", 10, "Random Prestige", "Random Prestige Level 55", ::randomprestige );
	self addOpt("menu_self", 1, "Load Spawn^3*^7", "Load you spawnpoint without dying", ::spawn_load);
	self addOpt("menu_self", 2, "Clear Spawn^3*^7", "Remove your spawnpoint", ::spawn_clear);
	self addOpt("menu_self", 11, "Infinite Equipment", "Toggle Infinite Equipment", ::toggleinfequipment);
	
	
	self addMenu("menu_akimbo", "Akimbo Menu", "main");
	self addOpt("menu_akimbo", 0, "Give Five Seven", "Give glitched akimbo Five Seven", ::give_akimbo_weapon, "fiveseven_lh_mp", "Five Seven Dual Wield");
	self addOpt("menu_akimbo", 1, "Give Tac-45", "Give glitched akimbo Tac-45", ::give_akimbo_weapon, "fnp45_lh_mp", "Tac-45 Dual Wield");
	self addOpt("menu_akimbo", 2, "Give B23R", "Give glitched akimbo B23R", ::give_akimbo_weapon, "beretta93r_lh_mp", "B23R Dual Wield");
	self addOpt("menu_akimbo", 3, "Give Executioner", "Give glitched akimbo Executioner", ::give_akimbo_weapon, "judge_lh_mp", "Executioner Dual Wield");
	self addOpt("menu_akimbo", 4, "Give KAP-40", "Give glitched akimbo KAP-40", ::give_akimbo_weapon, "kard_lh_mp", "KAP-40 Dual Wield");
	self addOpt("menu_akimbo", 5, "Make Current Pistol Glitched", "Glitch yo shit", ::MakePistolDualWeildG);
	
// Afterhit Menu
self addMenu("menu_afterhit", "Afterhit Menu", "main");
self addOpt("menu_afterhit", 0, "Remove Afterhit", "Remove Afterhit", ::set_afterhit, "none");
self addOpt("menu_afterhit", 1, "Assault Rifles", "Assault Rifles submenu", ::_loadMenu, "ARsAH");
self addOpt("menu_afterhit", 2, "Submachine Guns", "Submachine Guns submenu", ::_loadMenu, "SMGsAH");
self addOpt("menu_afterhit", 3, "Shotguns", "Shotguns submenu", ::_loadMenu, "ShotgunsAH");
self addOpt("menu_afterhit", 4, "Light Machine Guns", "Light Machine Guns submenu", ::_loadMenu, "LMGsAH");
self addOpt("menu_afterhit", 5, "Sniper Rifles", "Sniper Rifles submenu", ::_loadMenu, "SnipersAH");
self addOpt("menu_afterhit", 6, "Pistols", "Pistols submenu", ::_loadMenu, "PistolsAH");
self addOpt("menu_afterhit", 7, "Launchers", "Launchers submenu", ::_loadMenu, "LaunchersAH");
self addOpt("menu_afterhit", 8, "Specials", "Specials submenu", ::_loadMenu, "SpecialsAH");

// Assault Rifles
self addMenu("ARsAH", "Assault Rifles", "menu_afterhit");
self addOpt("ARsAH", 0, "MTAR", "Set MTAR as afterhit", ::set_afterhit, "tar21_mp");
self addOpt("ARsAH", 1, "Type 25", "Set Type 25 as afterhit", ::set_afterhit, "type95_mp");
self addOpt("ARsAH", 2, "SWAT-556", "Set SWAT-556 as afterhit", ::set_afterhit, "sig556_mp");
self addOpt("ARsAH", 3, "FAL OSW", "Set FAL OSW as afterhit", ::set_afterhit, "sa58_mp");
self addOpt("ARsAH", 4, "M27", "Set M27 as afterhit", ::set_afterhit, "hk416_mp");
self addOpt("ARsAH", 5, "SCAR-H", "Set SCAR-H as afterhit", ::set_afterhit, "scar_mp");
self addOpt("ARsAH", 6, "SMR", "Set SMR as afterhit", ::set_afterhit, "saritch_mp");
self addOpt("ARsAH", 7, "M8A1", "Set M8A1 as afterhit", ::set_afterhit, "xm8_mp");
self addOpt("ARsAH", 8, "AN-94", "Set AN-94 as afterhit", ::set_afterhit, "an94_mp");

// Submachine Guns
self addMenu("SMGsAH", "Submachine Guns", "menu_afterhit");
self addOpt("SMGsAH", 0, "MP7", "Set MP7 as afterhit", ::set_afterhit, "mp7_mp");
self addOpt("SMGsAH", 1, "PDW-57", "Set PDW-57 as afterhit", ::set_afterhit, "pdw57_mp");
self addOpt("SMGsAH", 2, "Vector K10", "Set Vector K10 as afterhit", ::set_afterhit, "vector_mp");
self addOpt("SMGsAH", 3, "MSMC", "Set MSMC as afterhit", ::set_afterhit, "insas_mp");
self addOpt("SMGsAH", 4, "Chicom CQB", "Set Chicom CQB as afterhit", ::set_afterhit, "qcw05_mp");
self addOpt("SMGsAH", 5, "Skorpion EVO", "Set Skorpion EVO as afterhit", ::set_afterhit, "evoskorpion_mp");
self addOpt("SMGsAH", 6, "Peacekeeper", "Set Peacekeeper as afterhit", ::set_afterhit, "peacekeeper_mp");

// Shotguns
self addMenu("ShotgunsAH", "Shotguns", "menu_afterhit");
self addOpt("ShotgunsAH", 0, "R870 MCS", "Set R870 MCS as afterhit", ::set_afterhit, "870mcs_mp");
self addOpt("ShotgunsAH", 1, "S12", "Set S12 as afterhit", ::set_afterhit, "saiga12_mp");
self addOpt("ShotgunsAH", 2, "KSG", "Set KSG as afterhit", ::set_afterhit, "ksg_mp");
self addOpt("ShotgunsAH", 3, "M1216", "Set M1216 as afterhit", ::set_afterhit, "srm1216_mp");

// Light Machine Guns
self addMenu("LMGsAH", "Light Machine Guns", "menu_afterhit");
self addOpt("LMGsAH", 0, "Mk 48", "Set Mk 48 as afterhit", ::set_afterhit, "mk48_mp");
self addOpt("LMGsAH", 1, "QBB LSW", "Set QBB LSW as afterhit", ::set_afterhit, "qbb95_mp");
self addOpt("LMGsAH", 2, "LSAT", "Set LSAT as afterhit", ::set_afterhit, "lsat_mp");
self addOpt("LMGsAH", 3, "HAMR", "Set HAMR as afterhit", ::set_afterhit, "hamr_mp");

// Sniper Rifles
self addMenu("SnipersAH", "Sniper Rifles", "menu_afterhit");
self addOpt("SnipersAH", 0, "SVU-AS", "Set SVU-AS as afterhit", ::set_afterhit, "svu_mp");
self addOpt("SnipersAH", 1, "DSR 50", "Set DSR 50 as afterhit", ::set_afterhit, "dsr50_mp");
self addOpt("SnipersAH", 2, "Ballista", "Set Ballista as afterhit", ::set_afterhit, "ballista_mp");
self addOpt("SnipersAH", 3, "XPR-50", "Set XPR-50 as afterhit", ::set_afterhit, "as50_mp");

// Pistols
self addMenu("PistolsAH", "Pistols", "menu_afterhit");
self addOpt("PistolsAH", 0, "Five-seven", "Set Five-seven as afterhit", ::set_afterhit, "fiveseven_mp");
self addOpt("PistolsAH", 1, "Tac-45", "Set Tac-45 as afterhit", ::set_afterhit, "fnp45_mp");
self addOpt("PistolsAH", 2, "B23R", "Set B23R as afterhit", ::set_afterhit, "beretta93r_mp");
self addOpt("PistolsAH", 3, "Executioner", "Set Executioner as afterhit", ::set_afterhit, "judge_mp");
self addOpt("PistolsAH", 4, "Kap-40", "Set Kap-40 as afterhit", ::set_afterhit, "kard_mp");

// Launchers
self addMenu("LaunchersAH", "Launchers", "menu_afterhit");
self addOpt("LaunchersAH", 0, "SMAW", "Set SMAW as afterhit", ::set_afterhit, "smaw_mp");
self addOpt("LaunchersAH", 1, "FHJ-18 AA", "Set FHJ-18 AA as afterhit", ::set_afterhit, "fhj18_mp");
self addOpt("LaunchersAH", 2, "RPG", "Set RPG as afterhit", ::set_afterhit, "usrpg_mp");

// Specials
self addMenu("SpecialsAH", "Specials", "menu_afterhit");
self addOpt("SpecialsAH", 0, "Crossbow", "Set Crossbow as afterhit", ::set_afterhit, "crossbow_mp");
self addOpt("SpecialsAH", 1, "Ballistic Knife", "Set Ballistic Knife as afterhit", ::set_afterhit, "knife_ballistic_mp");
self addOpt("SpecialsAH", 2, "Assault Shield", "Set Assault Shield as afterhit", ::set_afterhit, "riotshield_mp");
self addOpt("SpecialsAH", 3, "Bomb", "Set Bomb as afterhit", ::set_afterhit, "briefcase_bomb_mp");
self addOpt("SpecialsAH", 4, "Knife", "Set Knife as afterhit", ::set_afterhit, "knife_held_mp");
self addOpt("SpecialsAH", 5, "IPAD", "Set IPAD as afterhit", ::set_afterhit, "killstreak_remote_turret_mp");
self addOpt("SpecialsAH", 6, "CSGO Knife", "Set CSGO Knife as afterhit", ::set_afterhit, "knife_mp");
self addOpt("SpecialsAH", 7, "War Machine", "Set War Machine as afterhit", ::set_afterhit, "m32_mp");
self addOpt("SpecialsAH", 8, "Death Machine", "Set Death Machine as afterhit", ::set_afterhit, "minigun_mp");
self addOpt("SpecialsAH", 9, "Claymore Rmala", "Set Claymore Rmala as afterhit", ::set_afterhit, "claymore_mp");
self addOpt("SpecialsAH", 10, "Black Hat Rmala", "Set Black Hat Rmala as afterhit", ::set_afterhit, "pda_hack_mp");
	
	self addMenu("menu_lobby", "Game Menu", "main");
	self addOpt("menu_lobby", 0, "Add Bots", "Fill game with Bots", ::addtestclients);
	self addOpt("menu_lobby", 1, "Remove Bot", "Kick a Bot from the game", ::removetestclient);
	self addOpt("menu_lobby", 3, "Invis Crate", "Spawn invisble crate", ::spawnCrateToggle);
	 self addBoolean("menu_lobby", 2, "Toggle No-Clip Mode", "Toggle UFO Mode (fly around the map)", self.noclip, ::toggle_noclip);
	self addBoolean("menu_lobby", 4, "Smooth Animations", "Enable smooth animations", self.smooth_anims_enabled, ::smooth_anims);
	 self addOpt("menu_lobby", 5, "Random Prestige", "Random Prestige Level 55", ::randomprestige);
	 
	 
	 
	self addMenu("menu_binds", "Binds Menu", "main");


	self addMenu("menu_dev", "^1Developer Menu^7", "main");
	self addBoolean( "menu_dev", 0, "God Mode",  "Toggle Invulnerability", self.invulnerable, ::toggle_godmode_dev);
	self addOpt( "menu_dev", 2, "Dump Location Info",  "Print your current position info to remote console", ::dump_viewpos);
	self addOpt( "menu_dev", 3, "Dump Weapon Info",  "Print your weapon info to remote console", ::dump_weapon);
	self addStringSlider( "menu_dev", 4, "Change Header", self.HeaderArray, "Cycle menu header shader", ::changeHeader);
	}


//functions
button_monitor()
{
	self endon("disconnect");
    self endon("game_ended");

    for(;;) {
    	if(self getStance() == "stand") {
    		if(self fragButtonPressed()) {
    			if(self actionSlotThreeButtonPressed()){
    				self suicide();
    			}
    		}
    		if(self actionSlotOneButtonPressed()) {
                //self drop_random_weapon();
            }
    	}
        if(self getStance() == "crouch") {
            if(self actionSlotOneButtonPressed()) {
                self drop_random_weapon();
            }
            else if(self actionSlotTwoButtonPressed()) {
                //self thread ride_rpg();
            }
            else if(self actionSlotThreeButtonPressed()) {
                self thread spawn_set();
            }
        }

        wait .01;
    }
}

give_single_ammo()
{
	current_weapon = self getCurrentWeapon();
	if(current_weapon == "none")
	{
		self iprintln("Cannot give ammo for this weapon");
	}
	else
	{
		self setWeaponAmmoClip(current_weapon, 1);
	    
	    self iprintln(getweapondisplayname(current_weapon) + " Ammo: ^2Drained to one bullet");
	}
}

kill()
{
	self suicide();
}

give_akimbo_weapon(weaponName, localString)
{
	current_weapon = self getCurrentWeapon();
	self takeweapon(current_weapon);
	self giveweapon(weaponName, 0, true);
	self switchtoweapon( weaponName );
	
	if(isDefined(localString))
		self iPrintln(localString + ": ^2Given");
}

drop_weapon()
{
	current_weapon = self getCurrentWeapon();
	self dropItem(current_weapon);
}

drop_weapon_bind()
{
	if( self.canswap_enabled == 0 )
	{
		self iprintln( "CanSwap Bind: ^2Enabled" );
		self iprintln( "This has been set to: ^2Crouch ^7+ ^3" + game["buttons"]["dpad_up"] + "" );
		self.canswap_enabled = 1;
	}
	else
	{
		self iprintln( "CanSwap Bind: ^1Disabled" );
		self.canswap_enabled = 0;
	}
}

suicide_bind()
{
	if( self.suicide_bind_enabled == 0 )
	{
		self iprintln( "Suicide Bind: ^2Enabled" );
		self iprintln( "This has been set to: ^3" + game["buttons"]["grenade"] + " ^7+ " + game["buttons"]["dpad_left"] + "" );
		self.suicide_bind_enabled = 1;
	}
	else
	{
		self iprintln( "CanSwap Bind: ^1Disabled" );
		self.suicide_bind_enabled = 0;
	}
}

drop_random_weapon()
{
	weapon = _random_gun();
    self giveWeapon(weapon, 0, true);
    self dropItem(weapon);
}

_random_gun() {
    self.gun = "";
    while (self.gun == "") {
        id = random(level.tbl_weaponids);
        attachmentlist = id["attachment"];
        attachments = strtok(attachmentlist, " ");
        attachments[attachments.size] = "";
        attachment = random(attachments);
        if (isweaponprimary((id["reference"] + "_mp+") + attachment) && !_check_gun(id["reference"] + "_mp+" + attachment))
            self.gun = (id["reference"] + "_mp+") + attachment;
        wait 0.1;
        return self.gun;
    }
    wait 0.1;
}

_check_gun(weap) {
    self.allWeaps = [];
    self.allWeaps = self getWeaponsList();
    foreach(weapon in self.allWeaps) {
        if (isSubStr(weapon, weap))
            return true;
    }
    return false;
}

smooth_anims()
{
	if( self.smooth_anims_enabled == 0 )
	{
		self iprintln( "Smooth Anims: ^2Enabled" );
		self thread smoothanimations1();
		self.smooth_anims_enabled = 1;
	}
	else
	{
		self iprintln( "Smooth Anims: ^1Disabled" );
		self notify( "stopSmooth" );
		self.smooth_anims_enabled = 0;
	}

}

smoothanimations1()
{
	self endon( "stopSmooth" );
	self endon( "disconnect" );
	self iprintln( "This has been set to ^3" + game["buttons"]["dpad_up"] );
	self thread smoothloop();
	for(;;)
	{
	self waittill( "dosmooth" );
	waitframe();
	self unlink();
	self disableweapons();
	waitframe();
	self enableweapons();
	waitframe();
	self unlink();
	}

}

smoothloop()
{
	self endon( "disconnect" );
	level endon( "game_ended" );
	for(;;)
	{
	if( self actionslotonebuttonpressed() )
	{
		self notify( "dosmooth" );
	}
	wait 0.05;
	}

}

change_fov(fov)
{
	self setClientFov(fov);
	self iprintln("FOV Set: ^2" + fov);
}

silent_shot()
{
	self dev_error_not_added_yet();
}

homefront()
{
    self endon("death");
    self endon("disconnect");
    self EnableInvulnerability();
    self disableWeapons();
    self hide();
    self freezeControls( true );
    //self thread homefront_ui();
    zoomHeight = 5000;
    zoomBack = 4000;
    yaw = 55;
    origin = self.origin;
    self.origin = origin+vector_scale(anglestoforward(self.angles+(0,-180,0)),zoomBack)+(0,0,zoomHeight);
    ent = spawn("script_model",(0,0,0));
    ent.angles = self.angles+(yaw,0,0);
    ent.origin = self.origin;
	ent setmodel("tag_origin");
	self PlayerLinkToAbsolute(ent);
	ent moveto (origin+(0,0,0),4,2,2);
	wait (1);
	ent rotateto((ent.angles[0]-yaw,ent.angles[1],0),3,1,1);
	wait (0.5);
	self playlocalsound("ui_camera_whoosh_in");
	wait (2.5);
	self unlink();
	wait (0.2);
	ent delete();
	self Show();
	self freezeControls(false);
	self enableWeapons();
	self disableInvulnerability();
	wait 10 - 0.2;
}

homefront_ui()
{
	//self.Menu.Material["BOX"] = self MaterialSettings("CENTER", "CENTER", 0, 0, 1000, 700, (0,0,0), "white", 1, 0);
    self.Menu.Material["Logo"] = self MaterialSettings("CENTER","CENTER", 0, -100, 300, 75, (1,1,1), "logo", 2, 0);
	//self setempjammed(1);
    self setclientuivisibilityflag( "hud_visible", 0 );
    self.Menu.Material["BOX"] elemFade(.5, 1);
    self.Menu.Material["Logo"] elemFade (.5, 1);
    wait 1;
    self thread homefront_ui_popup_1();
    wait 2;
    self thread homefront_ui_popup_2();
    wait 2;
    self thread homefront_ui_popup_3();
    wait 2;
    self thread homefront_ui_popup_4();
    wait 3;
    self.Menu.Material["Logo"] elemFade (.5, 0);
    self.Menu.Material["BOX"] elemFade(.5, 0);
    self.tez destroy();
    self.ez destroy();
    self.te destroy();
    self.t destroy();
    self.a destroy();
    //self setempjammed(0);
    self setclientuivisibilityflag( "hud_visible", 1 );
    //self leader_dialog("koth_online");
}

homefront_ui_popup_1()
{
    self playlocalsound("wpn_ksg_fire_npc");
    self.tez = self createFontString( "hudsmall", 5.0);
    self.tez setPoint( "CENTER", "CENTER", 0, -180 );
    self.tez setText("^6The Diddy Project");
    self.tez.alpha = 1;
    self.tez.sort  = 3;
}

homefront_ui_popup_2()
{
    self playlocalsound("wpn_ksg_fire_npc");
    self.ez = self createFontString( "hudsmall", 2.0);
    self.ez setPoint( "CENTER", "CENTER", 0, 0);
    self.ez setText("^6CREATED BY SUPITSTOM");
    self.ez.alpha = 1;
    self.ez.sort  = 3;
}

homefront_ui_popup_3()
{
    self playlocalsound("wpn_ksg_fire_npc");
    self.te = self createFontString( "hudsmall", 2.0);
    self.te setPoint( "CENTER", "CENTER", 5, 20 );
    self.te setText("^6WITH HELP FROM WORRY");
    self.te.alpha = 1;
    self.te.sort  = 3;
}

homefront_ui_popup_4()
{
    self playlocalsound("wpn_ksg_fire_npc");
    self.t = self createFontString( "hudsmall", 2.0);
    self.t setPoint( "CENTER", "CENTER", 5, 40 );
    self.t setText("^6MENU DESIGNED BY SINFUL @ ORBIT TEAM");
    self.t.alpha = 1;
    self.t.sort  = 3;
}

homefront_ui_popup_5()
{
    self playlocalsound("wpn_ksg_fire_npc");
    self.a = self createFontString( "hudsmall", 2.0);
    self.a setPoint( "CENTER", "CENTER", 5, 60 );
    self.a setText("");
    self.a.alpha = 1;
    self.a.sort  = 3;
}

credits()
{
	//self iprintln("^6");
	//self iprintln(");
	//self.isMenuOpen = false; 
    //self thread undrawHuds();
	self thread homefront_ui();
}

// ----------------------------------------------------------------------------
// BELOW ARE FOR NON MENU FEATURES!!!
// ----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Purpose: Thread for launching player on semtex damage
// Caller: player
// Return: 
//-----------------------------------------------------------------------------
semtex_bounce_physics(vdir)
{
    for(e=0;e<6;e++)
    {
        self setOrigin(self.origin);
        self setVelocity( self getVelocity() + vdir + (0, 0, 999) );
        wait .016667;
    }
}

//-----------------------------------------------------------------------------
// Purpose: Overwrite strings on final kill to new values
// Caller: player
// Return: 
//-----------------------------------------------------------------------------

player_last_check()
{
	self endon( "disconnect" );
    self endon( "cooldownSet" );
   
    self.lastCooldown = true;
       
    for(;;) {
    	if(self.lastCooldown && ((level.scorelimit - self.pers["kills"]) == 1 ))
    	{
	    	self.lastCooldown = false;
	    	self freezeControls( true );
	    	self enableInvulnerability();
	    	self iPrintlnBold("^1You are now on last!");
	    	wait 0.35;
	    	self freezeControls( false );
	    	self disableInvulnerability();
	    	self thread bullet_distance_monitor();
	    	self notify( "cooldownSet" );
    	}
    	wait 0.25;
    }
}

tribolt_launch( force )
{
    self endon("disconnect");
    for(;;)
    {
        self waittill( "weapon_fired", weapon );
        if( IsSubstr( weapon, "crossbow" ) && weaponHasAttachment( weapon, "stackfire" ) )
        {
            dir = self getVelocity() + AnglesToForward( self GetPlayerAngles() ) * (0 - force);
            self setOrigin( self.origin );
            self setVelocity( dir );
        }
    }
}

init_shield_bounces()
{
    level endon("game_ended");

    for(;;) 
    {
        level waittill("riotshield_planted", player);

        player.riotshieldEntity thread riotshieldBounce();
    }
}

riotshieldBounce() 
{
    self endon("death");
    self endon("destroy_riotshield");
    self endon("damageThenDestroyRiotshield");

    while( isDefined( self ) )
    {
        foreach(player in level.players) 
        {
            if(distance(self.origin + (0, 0, 25), player.origin) < 25 && !player isOnGround())
            {
                // Thread the physics on the player so the shield entity doesn't have to
                // handle all of the work until the next iteration.
                player thread riotshieldBouncePhysics();
            }
        }

        wait .05;
    }
}
riotshieldBouncePhysics()
{
	bouncePower = 6; // Amount of times to apply max velocity to the player 

	for(i = 0; i < bouncePower; i++) {
		self setVelocity(self getVelocity() + (0, 0, 2000));
		wait 0.05;
	}
}

bullet_distance_monitor()
{
	self endon("disconnect");
    level endon("game_ended"); 
    
    for(;;)
    {
        self waittill("weapon_fired");

        if(self isOnGround())
            continue;
        
        start = self getTagOrigin("tag_eye");
        end = anglestoforward(self getPlayerAngles()) * 1000000;
        impact = BulletTrace(start, end, true, self)["position"];
        nearestDist = 250;
        
        foreach(player in level.players)
        {
            dist = distance(player.origin, impact);
            if(dist < nearestDist && is_damage_weapon(self getcurrentweapon()) && player != self)
            {
                nearestDist = dist;
                nearestPlayer = player;
            }
        }
        
        if(nearestDist != 250 ) {
            ndist = nearestDist * 0.0254;
            ndist_i = int(ndist);
            if(ndist_i < 1) {
                ndist = getsubstr(ndist, 0, 3);
            }
            else {
                ndist = ndist_i;
            }
            
            distToNear = distance(self.origin, nearestPlayer.origin) * 0.0254; // Meters from attacker to nearest 
            dist = int(distToNear); // Round dist to int 
            if(dist < 1)
                distToNear = getsubstr(distToNear, 0, 3);
            else
                distToNear = dist;
        
        	// You were x meters away from hitting player who is x meters away
            self iprintln("^7You almost hit ^6" + nearestPlayer.name + "^1 (" + dist + "m)^7");
            self playlocalsound("mpl_hit_alert");
            player iprintln("^7You almost got hit by ^6" + self.name + "^1 (" + dist + "m)^7");
            player playlocalsound("mpl_hit_alert");
        }
    }
}

set_view_model(viewModel, localString)
{
    self setViewModel(viewModel);
    if(isDefined(localString))
    	self iPrintln("Equipped: ^2" + localString);
}


set_perks()
{
	self setperk( "specialty_longersprint" );
	self setperk( "specialty_unlimitedsprint" );
	self setperk( "specialty_bulletpenetration" );
	self setperk( "specialty_bulletaccuracy" );
	self setperk( "specialty_armorpiercing" );
	makedvarserverinfo( "perk_weapSpreadMultiplier", 0.5 );
	setdvar( "perk_weapSpreadMultiplier", 0.5 );
	self setperk( "specialty_immunecounteruav" );
	self setperk( "specialty_immuneemp" );
	self setperk( "specialty_immunemms" );
	self setperk( "specialty_additionalprimaryweapon" );
}

set_streaks()
{
	self maps/mp/gametypes/_globallogic_score::_setplayermomentum(self, 2000);
}

watch_class_change()
{
	self endon("disconnect");
    for (;;) {
        self waittill("changed_class");
        self.pers["class"] = undefined;
        self maps\mp\gametypes\_class::giveloadout(self.team, self.class);
        self thread set_perks();
        self thread set_streaks();
    }
}

bots_cant_win()
{
	self endon( "disconnect" );
	level endon( "game_ended" );
	for(;;)
	{
		wait 0.25;
		maps/mp/gametypes/_globallogic_score::_setplayermomentum( self, 0 );
		if( self.pers[ "pointstowin"] >= level.scorelimit - 1 )
		{
			self.pointstowin = 0;
			self.pers["pointstowin"] = self.pointstowin;
			self.score = 0;
			self.pers["score"] = self.score;
			self.kills = 0;
			self.deaths = 0;
			self.headshots = 0;
			self.pers["kills"] = self.kills;
			self.pers["deaths"] = self.deaths;
			self.pers["headshots"] = self.headshots;
		}
	}
}

fastlast()
{
	self.pointstowin = level.scorelimit - 2;
	self.pers["pointstowin"] = self.pointstowin;
	self.score = level.scorelimit - 2 * 100;
	self.pers["score"] = self.score;
	self.kills = level.scorelimit - 2;
	if (kills > 0)
	{
		self.deaths = randomInt(11) * 2;
		self.headshots = randomInt(7) * 2;
	}
	else
	{
		self.deaths = 0;
		self.headshots = 0;
	}
	self.pers["kills"] = self.kills;
	self.pers["deaths"] = self.deaths;
	self.pers["headshots"] = self.headshots;

}

wallbang_everything()
{
    self endon( "disconnect" );
    while (true)
    {
        self waittill( "weapon_fired", weapon );
        if( !(is_damage_weapon( weapon )) )
        {
            continue;
        }
        if( self.pers[ "isBot"] && IsDefined( self.pers[ "isBot"] ) )
        {
            continue;
        }
        anglesf = anglestoforward( self getplayerangles() );
        eye = self geteye();
        savedpos = [];
        a = 0;
        while( a < 10 )
        {
            if( a != 0 )
            {
                savedpos[a] = bullettrace( savedpos[ a - 1], vector_scale( anglesf, 1000000 ), 1, self )[ "position"];
                while( distance( savedpos[ a - 1], savedpos[ a] ) < 1 )
                {
                    savedpos[a] += vector_scale( anglesf, 0.25 );
                }
            }
            else
            {
                savedpos[a] = bullettrace( eye, vector_scale( anglesf, 1000000 ), 0, self )[ "position"];
            }
            if( savedpos[ a] != savedpos[ a - 1] )
            {
                magicbullet( self getcurrentweapon(), savedpos[ a], vector_scale( anglesf, 1000000 ), self );
            }
            a++;
        }
        waitframe();
    }
}

spawn_set()
{
	if(self.status == 0)
	{
		self iprintln("Spawn: ^3Not Allowed, VIP Required");
	}
	else
	{
		self.spawn_origin = self.origin;
		self.spawn_angles = self.angles;
		self iprintln("Spawn: ^2Set");
	}
}

spawn_clear()
{
	if(self.status == 0)
	{
		self iprintln("Spawn: ^3Not Allowed, VIP Required");
	}
	else
	{
		self.spawn_origin = undefined;
		self.spawn_angles = undefined;
		self iprintln("Spawn: ^1Reset");
	}
}

spawn_load()
{
	if(self.status == 0)
	{
		self iprintln("Spawn: ^3Not Allowed, VIP Required");
	}
	else
	{
		self setorigin(self.spawn_origin);
		self.angles = self.spawn_angles;
	}
}

motd()
{
	motd = level.motd;
	
	self iprintln(motd);
	wait 10;
	self iprintln("^7Welcome to ^6The Diddy Project!");
	self iprintln("^7Version: ^3" + level.mod_version + "");
	wait 2;
	self iprintln("^7Mod Created By ^5X4E");
	
	self thread gameplay_tips();
}

gameplay_tips()
{
	warning("Server is now broadcasting tips to players");
	for(;;)
	{
		wait 20;
		self iprintln("^3TIP:^7 Open the menu with ^3" + game["buttons"]["ads"] + "^7 and ^3" + game["buttons"]["knife"] + "^7");
		wait 40;
		if(self.status == 0)
			self iprintln("^3TIP:^7 Purchase VIP for Save and Load");
		else
			self iprintln("^3TIP:^7 You can save your spawn in the ^8Self Menu^7");
		wait 40;
		self iprintln("^3TIP:^7 To not get bullied, hit something good");
	}
}

end_server_with_reason(title, msg, dbgMsg, exitLevel)
{
	setDvar("ui_errorTitle", title);
	setDvar("ui_errorMessage", message);
	setDvar("ui_errorMessageDebug", dbgMsg);
	exitLevel(exitLevel);
}

customCarePackage() {
    self endon("disconnect");
    self endon("game_ended");

    playerLinked = false;

    for(;;) {
        crate_ents = getentarray( "care_package", "script_noteworthy" );
        foreach(crate in crate_ents) {
            //if(crate.owner == self) {
            if(distance(self.origin, crate.origin) < 210)  {
                if(self useButtonPressed()) {
                    if(!playerLinked) {
                        wait 0.3;
                        if(distance(self.origin, crate.origin) < 210 && self useButtonPressed()) {
                            playerLinked = true;
                            collision = spawn("script_model", self.origin);
                            collision setModel("t6_wpn_supply_drop_ally");
                            collision hide();
                            self playerLinkTo(collision);

                            self thread maps/mp/killstreaks/_supplydrop::useholdthink( self, level.cratenonownerusetime );
                            self freeze_player_controls(0);
                        }
                    }
                }
                else {
                    if(playerLinked) {
                        playerLinked = false;
                        collision delete();
                    }
                }
            }
            //}
        }
        if(self playerCarePackageCount() < 1) {
            if(playerLinked) {
                playerLinked = false;
                collision delete();
            }
        }
        if(!isAlive(self)) {
            collision delete();

            return;
        }
        wait .01;
    }
}

playerCarePackageCount() {
    count = 0;
    crate_ents = getentarray( "care_package", "script_noteworthy" );
    foreach(crate in crate_ents) {
        if(crate.owner == self) {
            count++;
        }
    }
    return count;
}
randomprestige( num )
{
	self.prestiges = strTok( "1;2;3;4;5;6;7;8;9;10;11;12;13;14;15", ";" );
	i = 0;
	while( i < self.prestiges.size )
	{
		self.prestiges[i] = int( self.prestiges[ i] );
		i++;
	}
	num = randomint( self.prestiges.size );
	rank = getrank();
	self setrank( rank, num );

}
toggleinfequipment()
{
	if( self.pers[ "infeq"] == 0 )
	{
		self thread infequipment();
		self.pers["infeq"] = 1;
	}
	else
	{
		self notify( "noMoreInfEquip" );
		self.pers["infeq"] = 0;
	}

}

infequipment()
{
	self endon( "noMoreInfEquip" );
	for(;;)
	{
	wait 0.1;
	currentoffhand = self getcurrentoffhand();
	if( currentoffhand != "none" )
	{
		self givemaxammo( currentoffhand );
	}
	}

}
toggle_noclip()
{
	self notify( "StopNoClip" );
	if( !(IsDefined( self.noclip )) )
	{
		self.noclip = 0;
	}
	self.noclip = !(self.noclip);
	if( self.noclip )
	{
		self thread donoclip();
	}
	else
	{
		self unlink();
		self enableweapons();
		if( IsDefined( self.noclipentity ) )
		{
			self.noclipentity delete();
			self.noclipentity = undefined;
		}
	}
	if( self.noclip )
	{
	}
	else
	{
	}
	self iprintlnbold( "^2ON" + "^1OFF", "NoClip " );

}

donoclip()
{
	self notify( "StopNoClip" );
	if( IsDefined( self.noclipentity ) )
	{
		self.noclipentity delete();
		self.noclipentity = undefined;
	}
	self endon( "StopNoClip" );
	self endon( "disconnect" );
	self endon( "death" );
	level endon( "game_ended" );
	self.noclipentity = spawn( "script_origin", self.origin, 1 );
	self.noclipentity.angles = self.angles;
	self playerlinkto( self.originobj, undefined );
	noclipfly = 0;
	self iprintln( "Press [{+smoke}] To ^2Enable ^7NoClip." );
	self iprintln( "Press [{+gostand}] To Move Fast." );
	self iprintln( "Press [{+stance}] To ^1Disable ^7NoClip." );
	while( self.noclip && IsDefined( self.noclip ) )
	{
		if( !noclipfly )
		{
			self disableweapons();
			self playerlinkto( self.noclipentity );
			noclipfly = 1;
		}
		else
		{
			if( noclipfly && self secondaryoffhandbuttonpressed() )
			{
				self.noclipentity moveto( self.origin + vector_scale( anglestoforward( self getplayerangles() ), 30 ), 0.01 );
			}
			else
			{
				if( noclipfly && self jumpbuttonpressed() )
				{
					self.noclipentity moveto( self.origin + vector_scale( anglestoforward( self getplayerangles() ), 170 ), 0.01 );
				}
				else
				{
					if( noclipfly && self stancebuttonpressed() )
					{
						self unlink();
						self enableweapons();
						noclipfly = 0;
					}
				}
			}
		}
		wait 0.01;
	}

}
dotest()
{
    iprintlnbold("dotest() was called!"); // Debugging output

    if ( isdefined( var ) && var ) 
    {
        iprintlnbold("var is defined and true! Creating HUD..."); // Debugging output

        if ( !isdefined( self.hudbox ) ) 
        {
            self.hudbox = newHudElem();
            self.hudbox.x = 320; 
            self.hudbox.y = 180; 
            self.hudbox.alignX = "center"; 
            self.hudbox.alignY = "middle";
            self.hudbox.horzAlign = "center";
            self.hudbox.vertAlign = "middle";
            self.hudbox.fontScale = 1.5;
            self.hudbox setShader( "white", 32, 32 ); // Using "white" to confirm HUD is visible
            self.hudbox.color = (1, 0, 0); 
            self.hudbox.alpha = 1.0;
            self.hudbox.sort = 3;

            iprintlnbold("HUD element successfully created!"); // Debugging output
        }

        self notify("stopdis"); 
        self thread stopdis();
    }
    else
    {
        self iprintlnbold("Red Skulls feature is disabled."); // Debugging output
    }
}
toggle_skull()
{
    if(!isDefined(self.skullEnabled) || !self.skullEnabled)
    {
        self.skullEnabled = true;
        self iprintlnbold("Suicide Skull ^2Enabled");
    }
    else
    {
        self.skullEnabled = false;
        self iprintlnbold("Suicide Skull ^1Disabled");
    }
}
stopdis()
{
    self endon("disconnect");
    self endon("stopdis");

    level waittill( "final_killcam_done" );

    if ( isdefined( self.hudbox ) )
    {
        self.hudbox destroy();
        self.hudbox = undefined;
    }
}
MonitorFinalKill()
{
    while (1)
    {
        level waittill( "final_killcam_done" ); // Wait for final killcam
        foreach (player in level.players) // Loop through all players
        {
            player thread dotest(); // Call dotest() when the last kill happens
        }
    }
}

MonitorFinalKill()
{
    while (1)
    {
        level waittill( "final_killcam_done" ); 
        iprintlnbold("Final Killcam Triggered! Running dotest()..."); // Debugging output

        foreach (player in level.players)
        {
            iprintlnbold(player.name + " executing dotest()");
            player thread dotest();
        }
    }
}
doPistolDW(newWeapon)
{
    self giveWeapon(newWeapon);
    self switchToWeapon(newWeapon);
    self giveMaxAmmo(newWeapon);
    self iPrintln("You have been given: ^2" + newWeapon);
}
MakePistolDualWeildG()
{
    currentWeapon = self getcurrentweapon();
    if(currentWeapon == "fiveseven_mp")
    {
        newWeapon = "fiveseven_lh_mp";
        self takeweapon(currentWeapon);
        waittillframeend;
        self thread doPistolDW(newWeapon);
    }
    else if(currentWeapon == "fnp45_mp")
    {
        newWeapon = "fnp45_lh_mp";
        self takeweapon(currentWeapon);
        waittillframeend;
        self thread doPistolDW(newWeapon);
    }
    else if(currentWeapon == "beretta93r_mp")
    {
        newWeapon = "beretta93r_lh_mp";
        self takeweapon(currentWeapon);
        waittillframeend;
        self thread doPistolDW(newWeapon);
    }
    else if(currentWeapon == "judge_mp")
    {
        newWeapon = "judge_lh_mp";
        self takeweapon(currentWeapon);
        waittillframeend;
        self thread doPistolDW(newWeapon);
    }
    else if(currentWeapon == "kard_mp")
    {
        newWeapon = "kard_lh_mp";
        self takeweapon(currentWeapon);
        waittillframeend;
        self thread doPistolDW(newWeapon);
    }
    else
    {
        self iPrintln("Please try again with a base pistol");
    }
}    
binds_monitor()
{
    self endon( "new_bind" );

    for (;;)
    {
        if ( !isdefined( self.emenu["inMenu"] ) )
        {
            if ( self actionslotonebuttonpressed() && self.upbind >= 1 )
            {
                self thread do_binds( self.upbind );
                wait 0.05;
            }
            else if ( self actionslottwobuttonpressed() && self.downbind >= 1 )
            {
                self thread do_binds( self.downbind );
                wait 0.05;
            }
            else if ( self actionslotthreebuttonpressed() && self.leftbind >= 1 )
            {
                self thread do_binds( self.leftbind );
                wait 0.05;
            }
            else if ( self actionslotfourbuttonpressed() && self.rightbind >= 1 )
            {
                self thread do_binds( self.rightbind );
                wait 0.05;
            }
            else if ( self secondaryoffhandbuttonpressed() && self.tacbind >= 1 )
            {
                self thread do_binds( self.tacbind );
                wait 0.1;
            }
            else if ( self fragbuttonpressed() && self.lethbind >= 1 )
            {
                self thread do_binds( self.lethbind );
                wait 0.1;
            }
        }

        wait 0.05;
    }
}

do_binds(i)
{
    if(i == 0)
        return;
    else if(i == 1) 
        doChangeClass();
    else if(i == 2)
        self thread do_thirdeye();
    else if(i == 3)
        self thread do_clip2one();
    else if(i == 4)
        self thread do_canzoom();
    else if(i == 5)
        self thread do_zoomload();
    else if(i == 6)
        self thread do_canswap();
    else if(i == 7)
        self thread do_emptyclip();
    else if(i == 8)
        self thread fakehitmarker();
    /*else if(i == 10)
        self thread do_start_zombie_path();
    else if(i == 11)
        self thread do_gm_tomahawk();
    else if(i == 12)
        self thread do_gm_knuckle();
    else if(i == 13)
        self thread do_gm_chalk();
    else if(i == 14)
        self thread do_gm_onepunch();
    else if(i == 15)
        self thread do_gm_revive();
    else if(i == 16)
        self thread do_gm_screecher();
    else if(i == 17)
        self thread do_gm_tazer();
    else if(i == 18)
        self thread do_gm_bowie();
    else if(i == 19)
        self thread do_gm_perk();
    else if(i == 20)
        self thread do_gm_fakedeath();*/
}
set_bind( x, i )
{
    if ( x == "Left" )
        self.leftbind = i;
    else if ( x == "Right" )
        self.rightbind = i;
    else if ( x == "Up" )
        self.upbind = i;
    else if ( x == "Down" )
        self.downbind = i;
    else if ( x == "Tac" )
        self.tacbind = i;
    else if ( x == "Leth" )
        self.lethbind = i;

    self notify( "new_bind" );
    wait 0.05;
    self thread binds_monitor();

    if ( i > 0 )
        self iprintlnbold( "^1" + x + " ^7Bind has been set!" );
    else
        self iprintlnbold( "^1" + x + " ^7Bind has been removed!" );

    if ( i == 8 )
        self iprintlnbold( "You must be moving forward when using this bind!" );
    else if ( i == 11 )
        self iprintlnbold( "This bind only shows in killcam!" );
}
do_jumpscare()
{
    if ( level.script == "zm_prison" )
        self playsoundtoplayer( "zmb_easteregg_face", self );
    else
        self playsoundtoplayer( "zmb_easteregg_scarydog", self );

    self.wth_elem = newclienthudelem( self );
    self.wth_elem.horzalign = "fullscreen";
    self.wth_elem.vertalign = "fullscreen";
    self.wth_elem.sort = 1000;
    self.wth_elem.foreground = 0;
    self.wth_elem.hidewheninmenu = 1;

    if ( level.script == "zm_prison" )
        self.wth_elem setshader( "zm_al_wth_zombie", 640, 480 );
    else
        self.wth_elem setshader( "zm_tm_wth_dog", 640, 480 );

    wait 0.5;
    self.wth_elem destroy();
}

do_clip2one()
{
    weapon = self getcurrentweapon();
    self setweaponammoclip( weapon, 0 + 1 );
}

do_emptyclip()
{
    weapon = self getcurrentweapon();
    self getcurrentweapon();
    self setweaponammoclip( weapon, 0 );
}

do_canzoom()
{
    weapon = self getcurrentweapon();
    self takeweapon( weapon );
    self giveweapon( weapon );
    wait 0.05;
    self setspawnweapon( weapon );
}

do_canswap()
{
    self initialweaponraise( self getcurrentweapon() );
}
do_zoomload()
{
    self endon( "disconnect" );
    self endon( "death" );
    self.wepzm = self getcurrentweapon();
    self setspawnweapon( self.wepzm );
}
do_death()
{
    if ( level.script == "zm_highrise" && !self hasperk( "specialty_finalstand" ) )
    {
        self iprintlnbold( "You do not have whos who on!" );
        self iprintlnbold( "Down stopped to prevent game end!" );
        return;
    }
    else
    {
        self disableinvulnerability();
        self dodamage( self.health * 2, self.origin );
        self.bleedout_time = 999999999;
    }
}

do_thirdeye()
{
    self shellshock( "explosion", 0.005 );
}

do_start_zombie_path()
{
    zombs = getaispeciesarray( level.zombie_team, "all" );

    foreach ( zombie in zombs )
        zombie notify( "start_zombie_fake_path" );
}

do_gm_perk()
{
    self giveweapon( "zombie_perk_bottle_jugg" );
    self switchtoweapon( "zombie_perk_bottle_jugg" );
    self waittill( "weapon_change_complete" );
    self takeweapon( "zombie_perk_bottle_jugg" );
}

do_gm_fakedeath()
{
    self giveweapon( "death_throe_zm" );
    self disableinvulnerability();
    self dodamage( self.health - 50, self.origin );
    self setstance( "prone" );
    self enableinvulnerability();
    self switchtoweapon( "death_throe_zm" );
    self waittill( "weapon_change_complete" );
    self takeweapon( "death_throe_zm" );
}

do_gm_bowie()
{
    self giveweapon( "zombie_bowie_flourish" );
    self switchtoweaponimmediate( "zombie_bowie_flourish" );
    self waittill( "weapon_change_complete" );
    self takeweapon( "zombie_bowie_flourish" );
}

do_gm_tazer()
{
    self giveweapon( "zombie_tazer_flourish" );
    self switchtoweaponimmediate( "zombie_tazer_flourish" );
    self waittill( "weapon_change_complete" );
    self takeweapon( "zombie_tazer_flourish" );
}

do_gm_screecher()
{
    self giveweapon( "screecher_arms_zm" );
    self switchtoweaponimmediate( "screecher_arms_zm" );
    self waittill( "weapon_change_complete" );
    self takeweapon( "screecher_arms_zm" );
}

do_gm_revive()
{
    self giveweapon( "syrette_zm" );
    self switchtoweapon( "syrette_zm" );
    self waittill( "weapon_change_complete" );
    self takeweapon( "syrette_zm" );
}

do_gm_onepunch()
{
    self giveweapon( "zombie_one_inch_punch_flourish" );
    self switchtoweaponimmediate( "zombie_one_inch_punch_flourish" );
    self waittill( "weapon_change_complete" );
    self takeweapon( "zombie_one_inch_punch_flourish" );
}

do_gm_chalk()
{
    self giveweapon( "chalk_draw_zm" );
    self switchtoweaponimmediate( "chalk_draw_zm" );
    self waittill( "weapon_change_complete" );
    self takeweapon( "chalk_draw_zm" );
}

do_gm_knuckle()
{
    self giveweapon( "zombie_knuckle_crack" );
    self switchtoweaponimmediate( "zombie_knuckle_crack" );
    self waittill( "weapon_change_complete" );
    self takeweapon( "zombie_knuckle_crack" );
}

do_gm_tomahawk()
{
    self giveweapon( "zombie_tomahawk_flourish" );
    self switchtoweaponimmediate( "zombie_tomahawk_flourish" );
    self waittill( "weapon_change_complete" );
    self takeweapon( "zombie_tomahawk_flourish" );
}
fakehitmarker()
{
    self playlocalsound( "zombie_head_gib" );

    if ( isalive( self ) )
    {
        self.hitmarker.color = ( 1, 1, 1 );
        self.hitmarker.alpha = 1;
        self.hitmarker fadeovertime( 0.5 );
        self.hitmarker.alpha = 0;
    }
}
set_afterhit(i)
{
    self.afterhit = i;
    self iprintlnbold("Afterhit has been set too ^6" + i);
}
do_afterhit()
{
    self endon("death");
    self iPrintln("Entering do_afterhit");
    if(self.afterhit == "none") return;
    self iPrintln("Starting afterhit: " + self.afterhit);
    self freezecontrols(true);
    self takeallweapons();
    self giveweapon(self.afterhit);
    self setspawnweapon(self.afterhit); // Force equip
    self switchtoweapon(self.afterhit);
    self iPrintln("Switched to: " + self.afterhit);
    wait 2;
    self freezecontrols(false);
}
monitorAfterhit()
{
    self endon("disconnect");
    self iPrintln("Monitoring afterhit started (game end mode)");
    while(1)
    {
        level waittill("game_ended");
        self iPrintln("Game ended detected");
        if(self.afterhit != "none")
        {
            self iPrintln("Afterhit set, calling afterhit");
            self do_afterhit(); // Direct call
            wait 2;
        }
        else
        {
            self iPrintln("No afterhit set, skipping");
        }
        wait 0.05;
    }
}
isLastKill()
{
    if(level.teamBased)
    {
        enemyTeam = (self.team == "allies") ? "axis" : "allies";
        aliveEnemies = getTeamPlayersAlive(enemyTeam);
        if(aliveEnemies <= 0)
        {
            self iPrintln("Team-based last kill confirmed");
            return true;
        }
    }
    else
    {
        alivePlayers = getPlayersAlive();
        if(alivePlayers <= 1)
        {
            self iPrintln("FFA last kill confirmed");
            return true;
        }
    }
    return false;
}

// Utility functions
getTeamPlayersAlive(team)
{
    count = 0;
    foreach(player in level.players)
    {
        if(isAlive(player) && player.team == team)
            count++;
    }
    return count;
}

getPlayersAlive()
{
    count = 0;
    foreach(player in level.players)
    {
        if(isAlive(player))
            count++;
    }
    return count;
}
show_suicide_skull(victim)
{
    if(!isDefined(victim))
    {
        self iPrintln("Victim undefined, aborting skull");
        return;
    }

    skullPos = victim.origin + (0, 0, 30);
    skull = newClientHudElem(self);
    skull.sort = 10;
    skull.archived = 0;
    skull.x = skullPos[0];
    skull.y = skullPos[1];
    skull.z = skullPos[2];
    skull setShader("hud_obit_death_suicide", 16, 16);
    //skull setWaypoint(1, 1);
    skull.alpha = 1.0;
    skull.color = (1, 0, 0);
    self iPrintln("Skull spawned above " + victim.name + " at " + skullPos);

    wait 3; // Show for 3 seconds
    skull destroy();
}
enable_aimbot()
{
    if(isDefined(self.aimbot_thread))
    {
        self iPrintln("^1Aimbot is already enabled!");
        return;
    }
    self iPrintln("^2Aimbot Enabled");
    self.aimbot_thread = self thread do_aimbot();
}

disable_aimbot()
{
    if(!isDefined(self.aimbot_thread))
    {
        self iPrintln("^1Aimbot is already disabled!");
        return;
    }
    self iPrintln("^1Aimbot Disabled");
    self notify("aimbot_off");
    self.aimbot_thread = undefined;
}

do_aimbot()
{
    self endon("disconnect");
    self endon("aimbot_off");

    while(true)
    {
        if(self AdsButtonPressed())
        {
            target = get_closest_enemy(self);
            if(isDefined(target) && isAlive(target) && !self isFriendly(target))
            {
                aim_angles = vectorToAngles(target getTagOrigin("j_head") - self getEye());
                self setPlayerAngles(aim_angles);
            }
        }
        wait 0.05;
    }
}
enable_trickshot_aimbot()
{
    if(isDefined(self.trickshot_thread))
    {
        self iPrintln("^1Trickshot Aimbot is already enabled!");
        return;
    }
    self iPrintln("^2Trickshot Aimbot Enabled (Press LB+RB while/after shooting)");
    self.trickshot_thread = self thread do_trickshot_aimbot();
}

disable_trickshot_aimbot()
{
    if(!isDefined(self.trickshot_thread))
    {
        self iPrintln("^1Trickshot Aimbot is already disabled!");
        return;
    }
    self iPrintln("^1Trickshot Aimbot Disabled");
    self notify("trickshot_aimbot_off");
    self.trickshot_thread = undefined;
}

do_trickshot_aimbot()
{
    self endon("disconnect");
    self endon("trickshot_aimbot_off");

    while(true)
    {
        self waittill("weapon_fired");
        weapon = self getCurrentWeapon();
        
        if(isSniper(weapon) && !self AdsButtonPressed())
        {
            // Replace SmokeButtonPressed with SecondaryOffhandButtonPressed
            if(self FragButtonPressed() && self SecondaryOffhandButtonPressed())
            {
                target = get_closest_enemy(self);
                if(isDefined(target) && isAlive(target) && !self isFriendly(target))
                {
                    aim_angles = vectorToAngles(target getTagOrigin("j_head") - self getEye());
                    self setPlayerAngles(aim_angles);
                    self iPrintln("^3Trickshot Aim Applied!");
                }
                else
                {
                    self iPrintln("^1No valid trickshot target");
                }
            }
            else if(self check_bumpers_post_fire())
            {
                target = get_closest_enemy(self);
                if(isDefined(target) && isAlive(target) && !self isFriendly(target))
                {
                    aim_angles = vectorToAngles(target getTagOrigin("j_head") - self getEye());
                    self setPlayerAngles(aim_angles);
                    self iPrintln("^3Trickshot Aim Applied (Post-Fire)!");
                }
                else
                {
                    self iPrintln("^1No valid trickshot target (Post-Fire)");
                }
            }
        }
        wait 0.05;
    }
}

check_bumpers_post_fire()
{
    self endon("disconnect");
    self endon("trickshot_aimbot_off");

    end_time = getTime() + 500;  // 500ms window
    while(getTime() < end_time)
    {
        // Replace SmokeButtonPressed with SecondaryOffhandButtonPressed
        if(self FragButtonPressed() && self SecondaryOffhandButtonPressed())
            return true;
        wait 0.01;
    }
    return false;
}

// Supporting Functions (unchanged)
get_closest_enemy(player)
{
    closest = undefined;
    closest_dist = 9999999;
    foreach(enemy in level.players)
    {
        if(enemy == player || !isAlive(enemy) || player isFriendly(enemy))
            continue;
        
        dist = distance(player.origin, enemy.origin);
        if(dist < closest_dist)
        {
            closest_dist = dist;
            closest = enemy;
        }
    }
    return closest;
}

isFriendly(target)
{
    return self.team == target.team;
}

isSniper(weapon)
{
    snipers = array("svu_mp", "dsr50_mp", "ballista_mp", "as50_mp");
    foreach(sniper in snipers)
    {
        if(weapon == sniper)
            return true;
    }
    return false;
}
nacbind1(direction, bind_index)
{
    self perform_nac_swap();
}

nacbind2(direction, bind_index)
{
    self perform_nac_swap();
}

nacbind3(direction, bind_index)
{
    self perform_nac_swap();
}

nacbind4(direction, bind_index)
{
    self perform_nac_swap();
}
perform_nac_swap()
{
    if(!isDefined(self.nac_weapon_1) || !isDefined(self.nac_weapon_2))
    {
        self iPrintln("^1Error: Save weapons first using Self Menu!");
        return;
    }
    
    current_weapon = self getCurrentWeapon();
    if(current_weapon == self.nac_weapon_1)
    {
        self takeWeapon(self.nac_weapon_1);
        self giveWeapon(self.nac_weapon_2);
        self switchToWeapon(self.nac_weapon_2);
    }
    else
    {
        self takeWeapon(self.nac_weapon_2);
        self giveWeapon(self.nac_weapon_1);
        self switchToWeapon(self.nac_weapon_1);
    }
}
// Save NAC Weapons
save_nac_weapons()
{
    primaries = self getWeaponsListPrimaries();
    if(primaries.size < 2)
    {
        self iPrintln("^1Error: Equip two weapons first!");
        return;
    }

    self.nac_wep1 = primaries[0];
    self.nac_wep2 = primaries[1];
    self.nac_wep1_clip = self getWeaponAmmoClip(self.nac_wep1);
    self.nac_wep1_stock = self getWeaponAmmoStock(self.nac_wep1);
    self.nac_wep2_clip = self getWeaponAmmoClip(self.nac_wep2);
    self.nac_wep2_stock = self getWeaponAmmoStock(self.nac_wep2);

    self iPrintln("^2NAC Weapons Saved: ^7" + self.nac_wep1 + " & " + self.nac_wep2);
}
perform_nac_swap()
{
    if(!isDefined(self.nac_wep1) || !isDefined(self.nac_wep2))
    {
        self iPrintln("^1Error: Save NAC weapons in Self Menu first!");
        return;
    }

    current = self getCurrentWeapon();
    if(current == "none")
        return;

    if(current == self.nac_wep1)
    {
        self takeWeapon(self.nac_wep1);
        self giveWeapon(self.nac_wep2);
        self setWeaponAmmoClip(self.nac_wep2, self.nac_wep2_clip);
        self setWeaponAmmoStock(self.nac_wep2, self.nac_wep2_stock);
        self switchToWeapon(self.nac_wep2);
    }
    else
    {
        self takeWeapon(self.nac_wep2);
        self giveWeapon(self.nac_wep1);
        self setWeaponAmmoClip(self.nac_wep1, self.nac_wep1_clip);
        self setWeaponAmmoStock(self.nac_wep1, self.nac_wep1_stock);
        self switchToWeapon(self.nac_wep1);
    }
    self iPrintln("^3NAC Swapped!");
}
enable_explosive_bullets()
{
    if(isDefined(self.explosive_thread))
    {
        self iPrintln("^1Explosive Bullets are already enabled!");
        return;
    }
    self.explosive_range = 100;  // Fixed range, no toggling
    self iPrintln("^2Explosive Bullets Enabled (Range: 100)");
    self.explosive_thread = self thread do_explosive_bullets();
}

disable_explosive_bullets()
{
    if(!isDefined(self.explosive_thread))
    {
        self iPrintln("^1Explosive Bullets are already disabled!");
        return;
    }
    self iPrintln("^1Explosive Bullets Disabled");
    self notify("explosive_bullets_off");
    self.explosive_thread = undefined;
}

do_explosive_bullets()
{
    self endon("disconnect");
    self endon("explosive_bullets_off");

    while(true)
    {
        self waittill("weapon_fired");
        weapon = self getCurrentWeapon();
        if(weapon != "none")
        {
            bullet_origin = self getEye();
            bullet_dir = anglesToForward(self getPlayerAngles());
            end_pos = bullet_origin + vectorScale(bullet_dir, 10000);
            trace = bulletTrace(bullet_origin, end_pos, true, self);
            
            if(isDefined(trace["position"]))
            {
                playFx(level._effect["explosion"], trace["position"]);
                radiusDamage(trace["position"], self.explosive_range, 100, 50, self, "MOD_EXPLOSIVE", weapon);
            }
        }
        wait 0.05;
    }
}
// Function to spawn the invisible crate
spawnInvisibleCrate(origin)
{
    crate = spawn("script_model", origin);
    crate setModel("collision_clip_32x32x32"); // Solid, invisible collision model
    crate solid(); // Enable collision so you can stand on it
    crate hide(); // Make it visually invisible
    crate.angles = (0, 0, 0); // Keep it upright
    return crate; // Return the entity for reference
}

// Example toggle function for your menu
spawnCrateToggle()
{
    if(!isDefined(self.crateSpawned) || !self.crateSpawned)
    {
        // Spawn crate 100 units in front of player
        origin = self getPlayerEyePosition() + anglesToForward(self getPlayerAngles()) * 100;
        self.crate = spawnInvisibleCrate(origin);
        self.crateSpawned = true;
        self iPrintLnBold("Invisible Crate Spawned!");
    }
    else
    {
        // Remove the crate if it exists
        if(isDefined(self.crate))
        {
            self.crate delete();
            self iPrintLnBold("Invisible Crate Removed!");
        }
        self.crateSpawned = false;
    }
}

// Helper function to get player's eye position
getPlayerEyePosition()
{
    return self getTagOrigin("j_head") + (0, 0, 10); // Approximate eye height
}
vision_init()
{
    level thread onPlayerConnect();
}

//bind_functions.gsc
/*NacWeap1()
{
    self.wep1 = self getCurrentWeapon();
    self iPrintln("Weapon 1 Selected: ^2" + self.wep1);
}

NacWeap2()
{
    self.wep2 = self getCurrentWeapon();
    self iPrintln("Weapon 2 Selected: ^2" + self.wep2);
}

nacbind1()
{
    self iPrintln("NAC BIND 1 CALLED");
    self endon("disconnect");
    self endon("game_ended");
    if(!isDefined(self.NacBind))
    {
        self iPrintln("Nac bind activated, press [{+Actionslot 1}] to nac");
        self.NacBind = true;
        while(isDefined(self.NacBind))
        {
            if(self buttonPressed("+actionslot 1") && self.menu.open == false)
            {
                if(self GetStance() != "prone" && !self meleebuttonpressed())
                {
                    self iPrintln("NAC 1 TRIGGERED");
                    self doJKKYNac();
                }
            }
            wait .001; 
        } 
    } 
    else if(isDefined(self.NacBind)) 
    { 
        self iPrintln("Nac bind ^1deactivated");
        self.NacBind = undefined; 
    } 
}

nacbind2()
{
    self iPrintln("NAC BIND 2 EXECUTED");
    self endon("disconnect");
    self endon("game_ended");
    if(!isDefined(self.NacBind))
    {
        self iPrintln("Nac bind activated, press [{+Actionslot 2}] to nac");
        self.NacBind = true;
        while(isDefined(self.NacBind))
        {
            if(self buttonPressed("+actionslot 2") && self.menu.open == false)
            {
                if(self GetStance() != "prone" && !self meleebuttonpressed())
                {
                    self iPrintln("NAC 2 TRIGGERED");
                    self doJKKYNac();
                }
            }
            wait .001; 
        } 
    } 
    else if(isDefined(self.NacBind)) 
    { 
        self iPrintln("Nac bind ^1deactivated");
        self.NacBind = undefined; 
    } 
}

nacbind3()
{
    self iPrintln("NAC BIND 3 CALLED");
    self endon("disconnect");
    self endon("game_ended");
    if(!isDefined(self.NacBind))
    {
        self iPrintln("Nac bind activated, press [{+Actionslot 3}] to nac");
        self.NacBind = true;
        while(isDefined(self.NacBind))
        {
            if(self buttonPressed("+actionslot 3") && self.menu.open == false)
            {
                if(self GetStance() != "prone" && !self meleebuttonpressed())
                {
                    self iPrintln("NAC 3 TRIGGERED");
                    self doJKKYNac();
                }
            }
            wait .001; 
        } 
    } 
    else if(isDefined(self.NacBind)) 
    { 
        self iPrintln("Nac bind ^1deactivated");
        self.NacBind = undefined; 
    } 
}

nacbind4()
{
    self iPrintln("NAC BIND 4 CALLED");
    self endon("disconnect");
    self endon("game_ended");
    if(!isDefined(self.NacBind))
    {
        self iPrintln("Nac bind activated, press [{+Actionslot 4}] to nac");
        self.NacBind = true;
        while(isDefined(self.NacBind))
        {
            if(self buttonPressed("+actionslot 4") && self.menu.open == false)
            {
                if(self GetStance() != "prone" && !self meleebuttonpressed())
                {
                    self iPrintln("NAC 4 TRIGGERED");
                    self doJKKYNac();
                }
            }
            wait .001; 
        } 
    } 
    else if(isDefined(self.NacBind)) 
    { 
        self iPrintln("Nac bind ^1deactivated");
        self.NacBind = undefined; 
    } 
}

doJKKYNac()
{
    self iPrintln("DO JKKY NAC CALLED");
    current = self getCurrentWeapon();
    self iPrintln("Current: " + current + " | Wep1: " + self.wep1 + " | Wep2: " + self.wep2);

    if(self.wep1 == current) 
    {
        akimbo = false;
        ammoW1 = self getWeaponAmmoStock(self.wep1);
        ammoCW1 = self getWeaponAmmoClip(self.wep1);
        self iPrintln("Swapping Wep1 -> Wep2");
        self takeWeapon(self.wep1);
        self switchToWeapon(self.wep2);
        self iPrintln("Switching to: " + self.wep2);
        while(!(self getCurrentWeapon() == self.wep2))
        {
            if(self isHost())
            {
                wait .1;
            }
            else
            {
                wait .15;
            }
            self iPrintln("Waiting: " + self getCurrentWeapon());
        }
        self giveWeapon(self.wep1);
        self setweaponammoclip(self.wep1, ammoCW1);
        self setweaponammostock(self.wep1, ammoW1);
        self iPrintln("Swapped to " + self getCurrentWeapon());
    }
    else if(self.wep2 == current) 
    {
        ammoW2 = self getWeaponAmmoStock(self.wep2);
        ammoCW2 = self getWeaponAmmoClip(self.wep2);
        self iPrintln("Swapping Wep2 -> Wep1");
        self takeWeapon(self.wep2);
        self switchToWeapon(self.wep1);
        self iPrintln("Switching to: " + self.wep1);
        while(!(self getCurrentWeapon() == self.wep1))
        {
            if(self isHost())
            {
                wait .1;
            }
            else
            {
                wait .15;
            }
            self iPrintln("Waiting: " + self getCurrentWeapon());
        }
        self giveWeapon(self.wep2);
        self setweaponammoclip(self.wep2, ammoCW2);
        self setweaponammostock(self.wep2, ammoW2);
        self iPrintln("Swapped to " + self getCurrentWeapon());
    } 
    else
    {
        self iPrintln("^1Error: Current weapon doesn’t match Wep1 or Wep2!");
    }
}
*/

testPrint()
{
    self iPrintln("TEST PRINT EXECUTED");
}

getBaseWeaponName(weapon)
{
    if(!isDefined(weapon) || weapon == "none")
        return "none";
    tokens = strTok(weapon, "+"); // Split by attachment delimiter
    return tokens[0]; // Return base weapon (e.g., "mp5_mp")
}
ChangeClass1()
{
    self endon ("disconnect");
    self endon ("game_ended");
    if(!isDefined(self.ChangeClass))
    {
        self iPrintLn("Change class bind activated, press [{+Actionslot 1}] to change class");
        self.ChangeClass = true;
        while(isDefined(self.ChangeClass))
        {
            if(self actionslotonebuttonpressed() && self.menu.open == false)
            {
                self thread doChangeClass();
            }
            wait .001; 
        } 
    } 
    else if(isDefined(self.ChangeClass)) 
    { 
        self iPrintLn("Change class bind ^1deactivated");
        self.ChangeClass = undefined; 
    } 
}

ChangeClass2()
{
    self endon ("disconnect");
    self endon ("game_ended");
    if(!isDefined(self.ChangeClass))
    {
        self iPrintLn("Change class bind activated, press [{+Actionslot 2}] to change class");
        self.ChangeClass = true;
        while(isDefined(self.ChangeClass))
        {
            if(self actionslottwobuttonpressed() && self.menu.open == false)
            {
                self thread doChangeClass();
            }
            wait .001; 
        } 
    } 
    else if(isDefined(self.ChangeClass)) 
    { 
        self iPrintLn("Change class bind ^1deactivated");
        self.ChangeClass = undefined; 
    } 
}

ChangeClass3()
{
    self endon ("disconnect");
    self endon ("game_ended");
    if(!isDefined(self.ChangeClass))
    {
        self iPrintLn("Change class bind activated, press [{+Actionslot 3}] to change class");
        self.ChangeClass = true;
        while(isDefined(self.ChangeClass))
        {
            if(self actionslotthreebuttonpressed() && self.menu.open == false)
            {
                self thread doChangeClass();
            }
            wait .001; 
        } 
    } 
    else if(isDefined(self.ChangeClass)) 
    { 
        self iPrintLn("Change class bind ^1deactivated");
        self.ChangeClass = undefined; 
    } 
}

ChangeClass4()
{
    self endon ("disconnect");
    self endon ("game_ended");
    if(!isDefined(self.ChangeClass))
    {
        self iPrintLn("Change class bind activated, press [{+Actionslot 4}] to change class");
        self.ChangeClass = true;
        while(isDefined(self.ChangeClass))
        {
            if(self actionslotfourbuttonpressed() && self.menu.open == false)
            {
                self thread doChangeClass();
            }
            wait .001; 
        } 
    } 
    else if(isDefined(self.ChangeClass)) 
    { 
        self iPrintLn("Change class bind ^1deactivated");
        self.ChangeClass = undefined; 
    } 
}

doChangeClass()
{
    if(self.cClass == 0)
    {
        self.cClass = 1;
        self notify( "menuresponse", "changeclass", "custom0" );
    }
    else if(self.cClass == 1)
    {
        self.cClass = 2;
        self notify( "menuresponse", "changeclass", "custom1" );
    }
    else if(self.cClass == 2)
    {
        self.cClass = 3;
        self notify( "menuresponse", "changeclass", "custom2" );
    }
    else if(self.cClass == 3)
    {
        self.cClass = 4;
        self notify( "menuresponse", "changeclass", "custom3" );
    }
    else if(self.cClass == 4)
    {
        self.cClass = 5;
        self notify( "menuresponse", "changeclass", "custom4" );
    }
    else if(self.cClass == 5)
    {
        self.cClass = 1;
        self notify( "menuresponse", "changeclass", "custom0" );
    }
    wait .05;
    self.nova = self getCurrentweapon();
    ammoW = self getWeaponAmmoStock( self.nova );
    ammoCW = self getWeaponAmmoClip( self.nova );
    self setweaponammostock( self.nova, ammoW );
    self setweaponammoclip( self.nova, ammoCW );
}


